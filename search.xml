<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java开发手册学习：编程规约（一、二、三）</title>
    <url>/2021/06/07/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本手册以 Java 开发者为中 心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL 数据库、工程结构、设计规约 七个维度，再根据内容特征，细分成若干二级子目录。另外，依据约束力强弱及故障敏感性，规约依 次分为<font color="red">【强制】</font>、<font color="orange">【推荐】</font>、<font color="green">【参考】</font>三大类。在延伸信息中，<font color="orange">“说明”</font>对规约做了适当扩展和解释; <font color="green">“正例”</font>提倡什么样的编码和实现方式;<font color="red">“反例”</font>说明需要提防的雷区，以及真实的错误案例。</p>
<a id="more"></a>

<h1 id="一、命名风格"><a href="#一、命名风格" class="headerlink" title="一、命名风格"></a>一、命名风格</h1><p>1、<font color="red">【强制】</font> 代码中的命名均不能以 <strong>下划线或美元符号 **开始，也不能以 **下划线或者美元符号</strong> 结束</p>
<p>2、<font color="red">【强制】</font> 所有变成相关的命名 <strong>严禁拼音和英文混合</strong>，更 <strong>不允许直接使用中文</strong></p>
<p><font color="red">反例：</font> DaZhePromotion 、 getPingFenByName</p>
<p>3、<font color="red">【强制】</font> 代码和注释中避免使用任何语言的 <strong>种族歧视语言</strong></p>
<p>4、<font color="red">【强制】</font> 类名使用 UpperCamleCase 风格， 但以下情形例外 DO / BO / DTO/ VO / AO/ PO / UID</p>
<p>DTO：前后端交互：在后端，是 controller 接收的 java 对象，在前端，是 json，也可以是 ajax 请求数据体；</p>
<p>微服务：本身的一个隐含意义就是能够完整表达一个业务模块的输出，如果服务间互相独立就叫DTO，如果服务间并非是一个完整业务则为BO</p>
<p>VO（value object）值对象：一般是展示用的数据，主要形式是返回给前端 json 展示的对象。一般会对基础信息进行转义</p>
<p>PO（Persistant Object）持久化对象/DO（Data Object）数据对象：与Entity、domain等概念一样，指代数据库表对应的对象，只有get/set 没有逻辑；</p>
<p>BO（Business Object）：业务对象</p>
<p>DAO（Data Access Object）：数据访问对象</p>
<p>5、<font color="red">【强制】</font> 方法名、参数名、成员变量、局部变量统一使用 <strong>lowerCamelCase</strong> 风格</p>
<p>6、<font color="red">【强制】</font> 常量命名全部大写，单词间用下划线隔开，语义完整表达</p>
<p><font color="green">正例：</font> MAX_STOCK_COUNT / CACHE_EXPIRED_TIME</p>
<p><font color="red">反例：</font> MAX_COUNT / EXPIRED_TIME</p>
<p>7、<font color="red">【强制】</font> 抽象类命名使用 Abstract 或 Base 开头，异常类命名使用 Exception 结尾； 测试类命名以他要测试的类名开始+ Test 结束</p>
<p>8、<font color="red">【强制】</font> 类型与中括号紧挨相连以表示数组；</p>
<p><font color="green">正例：</font> int[] arrayDemo</p>
<p><font color="red">反例：</font> int arrayDemo[]</p>
<p>9、<font color="red">【强制】</font>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误</p>
<p><font color="orange">说明：</font> 数据库中 是否的字段用 is_xxx 的命名方式，所以，需要再 &lt;resultMap&gt; 设置从  is_xxx 到 xxx 的映射关系</p>
<p><font color="red">反例：</font> 定义基本数据类型 Boolean isDeleted 的属性，他的方法是 isDeleted()，框架在反向解析的时候，误以为对应的属性名是 deleted，导致属性获取不到，进而异常</p>
<p>10、<font color="red">【强制】</font> 包名统一使用小写，点分隔符直接有且仅有一个自然语义的英语单词，包名统一使用 <strong>单数</strong> 形式，但是类名如果有复数含义，类名可以用复数形式</p>
<p>11、<font color="red">【强制】</font> 避免在父子类的成员变量之间、或者不同代码块的局部变量之间采取完全相同的命名，使可理解性降低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfusingName</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> stock;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 非 setter / getter 的参数名称，不允许与本类成员变量同名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String ali)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> money = <span class="number">666</span>;</span><br><span class="line">    	……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="comment">// 在同一个方法体中，不允许与其他代码块中的 money 命名相同</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> money = <span class="number">12345</span>;</span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">ConfusingName</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许与父类的成员变量同名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> stock;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12、<font color="red">【强制】</font> 杜绝完全不规范的缩写，避免望文不生义</p>
<p><font color="red">反例：</font> AbstractClass 缩写成 AbsClass； condition 缩写成 condi</p>
<p>13、<font color="orange">【推荐】</font> 任何自定义编程元素在命名时，使用尽量完整的单词组合来表达</p>
<p>14、<font color="orange">【推荐】</font> 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度</p>
<p><font color="green">正例：</font> startTime / workQueue / nameList / END_TIME</p>
<p><font color="red">反例：</font> startedAt / QueueOfWork / listName / TIME_END</p>
<p>15、<font color="orange">【推荐】</font> 如果模块、接口、类、方法都是用了设计模式，在命名时需要体现出具体模式</p>
<p><font color="green">正例：</font> OrderFactory、LoginProxy、 ResourceObserver</p>
<p>16、<font color="orange">【推荐】</font> 接口类中的方法和属性不要加任何修饰符号（包括public），保持代码简洁，并加上有效的javaDoc注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础变量</p>
<p><font color="green">正例：</font> 接口方法签名 void commit();   接口基础常量 String COMPANY = “alibaba”;</p>
<p><font color="red">反例：</font> 接口方法定义 public abstract void f();</p>
<p>17、接口和实现类的命名有两套规则</p>
<p>1）<font color="red">【强制】</font> 对于 Service 和 DAO类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别</p>
<p>2）<font color="orange">【推荐】</font> 如果是形容能力的接口，取对应的形容词为接口名（通常是-able的形容词）</p>
<p><font color="green">正例：</font> AbstractTranslator 实现 Translatable 接口</p>
<p>18、<font color="green">【参考】</font> 枚举类命带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开； 枚举其实是特殊的常量类，且构造方法被默认强制是私有</p>
<p>19、<font color="green">【参考】</font> 各层命名规范：</p>
<p>A、Service / DAO 层方法命名规约</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">获取单个对象的方法用 **get** 做前缀</span><br><span class="line">获取多个对象的方法用 **list** 做前缀，复数结尾，如：listObjects</span><br><span class="line">获取统计值的方法用 **count** 做前缀</span><br><span class="line">插入的方法用 **save / insert** 做前缀</span><br><span class="line">删除的方法用 **remove / delete**  做前缀</span><br><span class="line">修改的方法用 **update**  做前缀</span><br></pre></td></tr></table></figure>
<p>B、领域模型命名规则</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">数据对象：xxxDO，xxx为数据库名</span><br><span class="line">数据传输对象：xxxDTO，xxx为业务领域相关的名称</span><br><span class="line">展示对象：xxxVO，xxx一般是网页名称</span><br><span class="line">POJO是 DO、DTO、BO、VO 的统称，禁止命名成 xxxPOJO</span><br></pre></td></tr></table></figure>


<h1 id="二、常量定义"><a href="#二、常量定义" class="headerlink" title="二、常量定义"></a>二、常量定义</h1><p>1、<font color="red">【强制】</font> 不允许任何魔法值（即未经定义的常量）直接出现在代码中</p>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 开发设置了前缀</span></span><br><span class="line">String keyA = “taobao_” + id；</span><br><span class="line"><span class="comment">// B 开发调用时漏掉 _</span></span><br><span class="line">String keyB = “taobao” + id；</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String PREFIX = <span class="string">&quot;taobao&quot;</span>;</span><br><span class="line">String key = PREFIX + id;</span><br></pre></td></tr></table></figure>
<p>2、<font color="red">【强制】</font> 在 long 或者 Long 赋值时，数值后使用大写字母L 不能用小写字母l ，小写字母容易饿跟数字1混淆</p>
<p>3、<font color="orange">【推荐】</font> 不要用一个常量类维护所有常量，要按照常量功能进行归类，分开维护</p>
<p>4、<font color="orange">【推荐】</font> 常量的附庸层次有五层，跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
<ul>
<li>跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录中</li>
<li>应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录中</li>
<li>子工程内部共享变量：即在当前子工程的 constant 目录中</li>
<li>包内共享常量：即在当前包下单独的 constant 中</li>
<li>类内共享常量：直接在类内部 private static final 定义</li>
</ul>
<p>5、<font color="orange">【推荐】</font> 如果变量值仅在一个范围内变化，用 enum 类型来定义</p>
<h1 id="三、代码格式"><a href="#三、代码格式" class="headerlink" title="三、代码格式"></a>三、代码格式</h1><p>1、<font color="red">【强制】</font> 如果是大括号内容为空，则简洁写成 {} 即可，大括号中间无需换行和空格；如果是非空代码块则</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>右大括号后还有 else 等代码则不换行；表示终止的后大括号后必须换行</li>
</ul>
<p>2、<font color="red">【强制】</font> 左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；</p>
<p>而左大括号前需要加空格</p>
<p><font color="green">正例：</font> if (a==b)</p>
<p><font color="red">反例：</font> if( a==b )</p>
<p>3、<font color="red">【强制】</font> if / for / while / switch / do 等保留字与括号之间必须加空格</p>
<p>4、<font color="red">【强制】</font> 任何二目、三目运算符的左右两边都需要加一个空格（包括复制运算符 =，逻辑运算符 &amp;，加减乘除符号等）</p>
<p>5、<font color="red">【强制】</font> 采用4个空格缩进，禁止使用tab字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 缩进4个空格</span></span><br><span class="line">    String say = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">       ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行;左大括号后换行</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行</span></span><br><span class="line">      System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// 在右大括号后直接结束，则必须换行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、<font color="red">【强制】</font> 注释的双斜线与注释内容之间有且只有一个空格</p>
<p>7、<font color="red">【强制】</font> 在进行类型转换的时候，右括号与强制转换值之间不需要任何看空个隔开(int)value</p>
<p>8、<font color="red">【强制】</font> 单行字符数限制不超过120个，超出需要换行，遵循以下规则</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">第二行相对第一行缩进4个字符，从第三行开始，不再继续缩进（跟第二行对齐）</span><br><span class="line">运算符与下文一起换行</span><br><span class="line">方法调用的点符号与下文一起换行</span><br><span class="line">方法调用中的多个参数需要换行时，在逗号后换行</span><br><span class="line">在括号前不要换行</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> <span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点号一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;yang&quot;</span>).append(<span class="string">&quot;hao&quot;</span>)...</span><br><span class="line">		.append(<span class="string">&quot;chen&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;chen&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;chen&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，不要在括号前换行 </span></span><br><span class="line">	sb.append(<span class="string">&quot;you&quot;</span>).append(<span class="string">&quot;are&quot;</span>)...append</span><br><span class="line">		(<span class="string">&quot;lucky&quot;</span>);</span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过 120 个字符，逗号后才是换行处</span></span><br><span class="line">	method(args1, args2, args3, ... </span><br><span class="line">         , argsX);</span><br></pre></td></tr></table></figure>
<p>9、<font color="red">【强制】</font> 方法参数在定义和传入时，多个参数逗号后面必须加空格</p>
<p>10、<font color="red">【强制】</font> IDE的 text file encoding 设置为 UTF-8；IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式</p>
<p>11、<font color="orange">【推荐】</font> 单个方法的总行数不超过80行（不包括注释之外，左右大括号，方法内代码，空行，回车）</p>
<p>12、<font color="orange">【推荐】</font> 没有必要增加若干个空格来让变量的赋值等号与上一行对应位置的等号对齐</p>
<p>13、<font color="orange">【推荐】</font> 不同逻辑，不同语义，不同业务的代码之间插入一个空行分隔开来提升可读性（但没有必要插入多个空行）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码规范</tag>
        <tag>阿里Java手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发手册学习：编程规约（六、七）</title>
    <url>/2021/06/09/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="六、集合处理"><a href="#六、集合处理" class="headerlink" title="六、集合处理"></a>六、集合处理</h1><p>1、<font color="red">【强制】</font> 关于 hashCode 和 equals 的处理，遵循以下规则：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">只要覆写 equals，就必须覆写 hashCode</span><br><span class="line">因为 Set 存储的是不重复对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两个方法</span><br><span class="line">如果自定义对象作为Map的键，那么必须覆写 hashCode 和 equals</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 因为 String 覆写了 hashCode 和 equals 方法，所以选择 String 作为 key</p>
<p>2、<font color="red">【强制】</font> 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size() == 0 的方式</p>
<p>在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好</p>
<p>3、<font color="red">【强制】</font> 在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要使用含有参数类型的 ，参数名为 mergeFunction 的方法，否则当出现相同 key 值时会抛出 IllegalStateException 异常</p>
<p><font color="orange">说明：</font> 参数 mergeFunction 的作用是当 key 重复时，自定义对 value 的处理策略，(v1, v2) -&gt; v2) 指当key一致时，用新的 value 值替代旧值</p>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version&quot;</span>, <span class="number">12.10</span>));</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version&quot;</span>, <span class="number">12.19</span>));</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version&quot;</span>, <span class="number">6.28</span>));</span><br><span class="line"><span class="comment">// 生成的 map 集合中只有一个键值对:&#123;version=6.28&#125;</span></span><br><span class="line">Map&lt;String, Double&gt; map = pairArrayList.stream().collect(Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -&gt; v2));</span><br></pre></td></tr></table></figure>
<p><font color="red">反例：</font> toMap 应该加一个参数 (v1, v2)-&gt;v2 作为 merge 依据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] departments = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;iERP&quot;</span>, <span class="string">&quot;iERP&quot;</span>, <span class="string">&quot;EIBU&quot;</span>&#125;; </span><br><span class="line"><span class="comment">// 抛出 IllegalStateException 异常</span></span><br><span class="line">Map&lt;Integer, String&gt; map = Arrays.stream(departments)</span><br><span class="line">.collect(Collectors.toMap(String::hashCode, str -&gt; str));</span><br></pre></td></tr></table></figure>
<p>4、<font color="red">【强制】</font> 当使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛出 NPE 异常</p>
<p><font color="red">反例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version1&quot;</span>, <span class="number">8.3</span>));</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version2&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">Map&lt;String, Double&gt; map = pairArrayList.stream().collect(</span><br><span class="line"><span class="comment">// 抛出 NullPointerException 异常</span></span><br><span class="line">                Collectors.toMap(</span><br><span class="line">                        Pair::getKey,</span><br><span class="line">                        Pair::getValue,</span><br><span class="line">                        (v1, v2) -&gt; v2));</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 在 java.util.HashMap 的  merge 方法里会进行如下的判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == <span class="keyword">null</span> || remappingFunction == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version1&quot;</span>, <span class="number">8.3</span>));</span><br><span class="line">pairArrayList.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;version2&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">Map&lt;String, Double&gt; map = pairArrayList.stream().collect(</span><br><span class="line">                Collectors.toMap(</span><br><span class="line">                        Pair::getKey,</span><br><span class="line">                  <span class="comment">// 先在值中判断是否为空，为空设定一个默认值</span></span><br><span class="line">                        value -&gt; Optional.ofNullable(value).map</span><br><span class="line">                                (Pair::getValue).orElse(<span class="number">0D</span>),</span><br><span class="line">                        (v1, v2) -&gt; v2));</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// &#123;version2=0.0, version1=8.3&#125;</span></span><br></pre></td></tr></table></figure>
<p>5、<font color="red">【强制】</font> ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.RandomAccessSubList cannot be cast to java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> subList() 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于SubList 的所有操作最终会反映到原列表上</p>
<p>6、<font color="red">【强制】</font>使用 Map 的方法 keySet() / values() / entrySet() 返回集合对象时，不可以对其添加元素操作，否则会抛出 UnsupportedOperationException 异常</p>
<p>7、<font color="red">【强制】</font> Collections 类返回的对象，如：emptyList() / singletonList() 等就是 immutable list，不可对其进行添加或者删除元素操作</p>
<p><font color="red">反例：</font> 如果查询无结果，返回 Collections.emptyList() 空集对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常</p>
<p>8、<font color="red">【强制】</font> 在 subList 场景中，高度注意对父集合元素的增加和删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常</p>
<p>9、<font color="red">【强制】</font> 使用集合转换数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致，长度为0 的空数组</p>
<p><font color="red">反例：</font> 直接使用 toArray 无参方法，返回值只能是 Object[] 类，若强制转其他类型数组将会出现 ClassCastException 错误</p>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="string">&quot;guan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bao&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 在使用 toArray 带参方法，数组空间大小的length</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">等于0：动态创建与 size 相同的数组，性能最好</span><br><span class="line">大于 0 但小于 size：重新创建大小等于 size 的数组，增加 GC 的负担</span><br><span class="line">等于 size：在高并发的情况下，数组创建完成之前，size 正在变大的情况下，也会演变成情况 2</span><br><span class="line">大于 size：空间浪费，且在 size 处插入 null 值，存在 NPE 隐患</span><br></pre></td></tr></table></figure>
<p>10、<font color="red">【强制】</font> 在使用 Collection 接口任何实现类的 addAll() 方法时，都要对输入的集合参数进行 NPE 判断</p>
<p><font color="orange">说明：</font> 在 ArrayList#addAll 方法的第一行代码即 Object[] a = c.toArray(); 其中 c 为输入集合参数，如果为 null 会抛出 NPE 异常</p>
<p>11、<font color="red">【强制】</font> 使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，他的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常</p>
<p><font color="orange">说明：</font> asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;chen&quot;</span>, <span class="string">&quot;yang&quot;</span>, <span class="string">&quot;hao&quot;</span>&#125;;</span><br><span class="line">List list = Arrays.asList(str);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>list.add(“test”); 运行时会报 java.lang.UnsupportedOperationException 异常</p>
</li>
<li><p>如果在 asList 后通过 str[0]=”test”赋值，list 的数据也会变化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;chen&quot;</span>, <span class="string">&quot;yang&quot;</span>, <span class="string">&quot;hao&quot;</span>&#125;;</span><br><span class="line">List list = Arrays.asList(str);</span><br><span class="line">System.out.println(list);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// [chen, yang, hao]</span></span><br><span class="line"><span class="comment">// [test, yang, hao]</span></span><br></pre></td></tr></table></figure>
<p>12、<font color="red">【强制】</font> 泛型通配符 &lt;? extends T&gt; 来接收返回的数据，此写法的泛型集合不能使用 add 方法；而 &lt;? super T&gt; 不能使用 get 方法，两者在接口调用赋值的场景中容易出错</p>
<p><font color="orange">说明：</font> 扩展说一下 PECS（Producer Extends Cousumer Super）原则</p>
<blockquote>
<p>第一：频繁往外读取内容的，适合用 &lt;? extends T&gt;</p>
<p>第二：经常往里面插入内容，适合用&lt;? super T&gt;</p>
</blockquote>
<p>13、<font color="red">【强制】</font> 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断，避免抛出 ClassCastException 异常</p>
<p><font color="orange">说明：</font> 泛型是在 JDK5 后出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值</p>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; generics = <span class="keyword">null</span>;</span><br><span class="line">List notGenerics = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">notGenerics.add(<span class="keyword">new</span> Object());</span><br><span class="line">notGenerics.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">generics = notGenerics;</span><br><span class="line">String str = generics.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>14、<font color="red">【强制】</font> 不要在 forEach 循环里进行元素的 remove 、add 操作，remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁</p>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  String item = it.next();</span><br><span class="line">  <span class="keyword">if</span>(符合删除元素条件)&#123;</span><br><span class="line">    iterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String item : list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(item))&#123;</span><br><span class="line">    list.remove(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会报 java.util.ConcurrentModificationException 异常</span></span><br><span class="line"><span class="comment">// modCount用于记录变更次数,当add或者remove时,都会自增1, expectedModCount 初始化为 modCount</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15、<font color="red">【强制】</font> 在 JDK 7 版本及以上， Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛出 IllegalArgumentException 异常</p>
<blockquote>
<p>1、x，y 的比较结果 和 y，x 的比较结果相反</p>
<p>2、x &gt; y, y &gt; z,则 x &gt; z</p>
<p>3、x = y，则 x，z比较结果和 y，z 比较结果相同</p>
</blockquote>
<p><font color="red">反例：</font> 没有处理值相等的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; o.age? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o.age - <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16、<font color="orange">【推荐】</font> 集合泛型定义事，在 JDK 7 及以上，使用 diamond 语法或者全省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diamond 方式，即&lt;&gt;</span></span><br><span class="line">HashMap&lt;String, String&gt; userCache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 全省略方式</span></span><br><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>17、<font color="orange">【推荐】</font> 集合初始化时，指定集合初始值大小</p>
<p><font color="orange">说明：</font> HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值 （16）即可</p>
<p><font color="green">正例：</font> initialCapacity = (需要存储的元素个数 / 负载因子) + 1。负载因子 （loader factor）默认为 0.75，  如果暂时无法确定初始值，设置为16</p>
<p><font color="red">反例：</font> HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，resize() 方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达到千万级的时候会影响程序性能。</p>
<p>18、<font color="orange">【推荐】</font> 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历</p>
<p><font color="orange">说明：</font> keySet 其实是遍历了 2 次，一次是为了转为 Iterator 对象，另一次是从 hashMap 中取出 key 对应的 value。 而 entrySet 只是遍历了一次就把 key 和 value 都放到 entry 中，效率更高，如果是 JDK8 ,使用 Map.forEach 方法</p>
<p><font color="green">正例：</font>values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象，entrySet() 返回的是 K-V 值组合集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  Entry entry = iterator.next();</span><br><span class="line">  Object key = entry.getKey();</span><br><span class="line">  Object value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>19 、<font color="orange">【推荐】</font>高度注意 Map 类集合 K/V 能不能储存 null 值的情况，</p>
<table>
<thead>
<tr>
<th>集合类</th>
<th>key</th>
<th>value</th>
<th>super</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>锁分段技术(JDK8:CAS)</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<p><font color="red">反例：</font> 由于 HashMap 的干扰，但是 ConcurrentHashMap 是不允许存储 null 值的，会抛出 NPE 异常</p>
<p>20、<font color="green">【参考】</font>合理利用好的集合有序性（sort）和稳定性（order），避免集合的无序性（unsort）和不稳定行（unorder）带来的负面影响</p>
<p><font color="orange">说明：</font> 有序性是指遍历的结果是按某种比较规则依次排列的，稳定性值集合每次遍历的元素次序是一定的</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>有序性</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>unsort</td>
<td>order</td>
</tr>
<tr>
<td>HashMap</td>
<td>unsort</td>
<td>unorder</td>
</tr>
<tr>
<td>TreeSet</td>
<td>sort</td>
<td>order</td>
</tr>
</tbody></table>
<p>21、<font color="green">【参考】</font> 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作；</p>
<h1 id="七、并发处理"><a href="#七、并发处理" class="headerlink" title="七、并发处理"></a>七、并发处理</h1><p>1、<font color="red">【强制】</font> 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p>
<p><font color="orange">说明：</font> 资源驱动类，工具类，单例工厂需要注意</p>
<p>2、<font color="red">【强制】</font> 创建线程或线程池时请指定有意义的线程名称，方便出错的时候回溯</p>
<p><font color="green">正例：</font> 自定义线程工厂，并且根据外部特征进行分组，比如，来自同一个机房调用，把机房编号赋值给 whatFeatureOfGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger nextId =  <span class="keyword">new</span> AtomicInter(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义线程名称，利用jstack 排查问题时有帮助</span></span><br><span class="line">  UserThreadFactory(String whatFeatureOfGroup)&#123;</span><br><span class="line">    namePrefix = <span class="string">&quot;From UserThreadFactory&#x27;s &quot;</span> + whatFeatureOfGroup + <span class="string">&quot;-Worker-&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">    String name = namePrefix + nextId.getAndIncrement();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">null</span>, task, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(thread.getName());</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、<font color="red">【强制】</font>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</p>
<p><font color="orange">说明：</font> 线程池的好处是减少在创建和销毁线程上所消耗的时间以及对系统资源的开销。</p>
<p>4、<font color="red">【强制】</font> 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让开发更加明确线程池的运行规则，规避资源耗尽</p>
<p><font color="orange">说明：</font> Executors 返回的线程池对象弊端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FixedThreadPool 和 SingleThreadPool ：允许请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</span><br><span class="line">CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</span><br></pre></td></tr></table></figure>
<p>5、<font color="red">【强制】</font>SimpleDataFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类</p>
<p><font color="green">正例：</font> 使用 DateUtils 处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> DateFoemat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 如果是 JDK8 的应用，可以用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，SimpleDateFormat 里有一个Calendar 对象引用，他用来存储和这个 SimpleDateFormat 相关的日期信息，如果本身是 static，高并发场景下对象引用会被多个线程修改，导致幻读。官方给出的解释</p>
<blockquote>
<p>simple beautiful strong immutable thread-safe</p>
<p>简单美观强不可变线程安全</p>
</blockquote>
<p>6、<font color="red">【强制】</font> 必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响到后续业务逻辑和造成内存泄漏。</p>
<p><font color="green">正例：</font> 在代理中使用 try-finally 块进行回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectThreadLocal.set(userInfo);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  objectThreadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、<font color="red">【强制】</font>高并发时，同步调用应该去考量锁的性能损耗，能用无锁数据结构，就不要用锁，能锁区块，就不要锁整个方法体，能用对象锁，就不要用类锁。</p>
<p><font color="orange">说明：</font> 尽量锁最小的满足条件结构，避免在锁代码块中调用 RPC 方法</p>
<p>8、<font color="red">【强制】</font>对多个资源、数据库表、对象进行同时加锁时，需要保持一致的加锁顺序 ，否则可能会造成死锁。</p>
<p><font color="orange">说明：</font> 线程一需要对 A、B、C 依次全部加锁后才可已进行更新操作，那么线程二的加锁顺序也必须是 A、B、C 否则会可能发生死锁</p>
<p>9、<font color="red">【强制】</font>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 无法解锁</p>
<p><font color="orange">说明：</font> </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一、如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其他线程无法成功获取锁</span><br><span class="line">二、如果 lock 方法 在 try 代码块之内，可能由于其他方法抛出异常，导致在 finally 代码块中，</span><br><span class="line">unlock 对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），</span><br><span class="line">抛出 IllegalMonitorStateException 异常</span><br><span class="line">三、在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 如果此处抛出异常，则直接执行 finally 代码块，会直接抛出 IllegalMonitorStateException 异常</span></span><br><span class="line">	doSomething();</span><br><span class="line">	lock.lock();</span><br><span class="line">  doOther();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10、<font color="red">【强制】</font>在使用常识机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则和锁的阻塞等待方式相同</p>
<p><font color="orange">说明：</font> Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），<br>抛出 IllegalMonitorStateException 异常</p>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">boolean</span> isLocked = lock.tryLock();</span><br><span class="line"><span class="keyword">if</span>(isLocked)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    doSth();</span><br><span class="line">    doOthers();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11、<font color="red">【强制】</font>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁加锁，使用 version 作为更新依据</p>
<p><font color="orange">说明：</font> 如果每次访问冲突概率小于 20%，使用乐观锁，否则用悲观锁。乐观锁的重试次数不得小于3次</p>
<p>12、<font color="red">【强制】</font> 多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题</p>
<p>13、<font color="orange">【推荐】</font> 资金相关的金融敏感信息，使用悲观锁策略</p>
<p><font color="orange">说明：</font> 乐观锁在获得锁的同时已经完成更新操作，检验逻辑容易出现漏洞。另外，乐观锁对冲突的解决策略又较复杂的要求，处理不当容易造成系统或数据压力。</p>
<blockquote>
<p>悲观锁遵循 一锁、二判、三更新、四释放的原则</p>
</blockquote>
<p>14、<font color="orange">【推荐】</font>使用 CountDownLatch 进行异步转同步操作，每个线程退出前调用 countDown 方法，线程执行 代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，知道超时才返回结果</p>
<p><font color="orange">说明：</font> 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到</p>
<p>15、<font color="orange">【推荐】</font>避免 Random 实例被多线程使用，虽然共享该实例时线程安全的，但会因竞争同一个 seed 导致性能下降</p>
<p><font color="orange">说明：</font> Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式；</p>
<p><font color="green">正例：</font>在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要保证每个线程持有一个单独的 Random 实例</p>
<p>16、<font color="orange">【推荐】</font>通过双重检查锁( double-checked locking) 在并发场景下存在延迟初始化的优化问题隐患。解决方案：将目标属性声明为 volatile 型，比如将 helper 的属性声明修改为：</p>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(helper == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper == <span class="keyword">null</span>)&#123;</span><br><span class="line">          helper = <span class="keyword">new</span> Helper();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> helper</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17、<font color="green">【参考】</font>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但如果多写，同样无法解决线程安全问题</p>
<p><font color="orange">说明：</font> 如果是 count++ 操作，使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInter();</span><br><span class="line">count.addAndGet(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk8 推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）</span></span><br><span class="line"><span class="comment">// LongAdder 使用 cells 实现分摊高并发下的累加压力</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.jianshu.com/p/381f9b39c941">AtomicLong和LongAdder的区别</a></p>
<p><a href="https://blog.csdn.net/h2604396739/article/details/86720618">从AtomicLong到LongAdder，LongAdder的原理</a></p>
</blockquote>
<p>18、<font color="green">【参考】</font> HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避</p>
<p>19、<font color="green">【参考】</font>ThreadLocal 对象使用 static 修饰， ThreadLocal 无法解决共享对象的更新问题</p>
<p><font color="orange">说明：</font> 该变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时加载，只分配一块存储空间，所有此类的对象都可以操控这个变量</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码规范</tag>
        <tag>阿里Java手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发手册学习：编程规约（四、五）</title>
    <url>/2021/06/08/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="四、OPP规约"><a href="#四、OPP规约" class="headerlink" title="四、OPP规约"></a>四、OPP规约</h1><p>1、<font color="red">【强制】</font> 避免通过一个类的对象来引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接使用 <strong>类名</strong> 来请求就行（不要new 静态对象访问）</p>
<p>2、<font color="red">【强制】</font> 所有的覆写方法，必须加 @Override 注解</p>
<p>3、<font color="red">【强制】</font> 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放置在参数列表的最后</p>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; listUsers（String type, Long... ids）&#123;……&#125;</span><br></pre></td></tr></table></figure>
<p>4、<font color="red">【强制】</font> 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰说明采用的新接口或者新服务是什么</p>
<p>5、<font color="red">【强制】</font> 不能使用过时的类或者方法</p>
<p>6、<font color="red">【强制】</font> Object 的 equals 方法容易抛空指针异常，应该使用常量或者确定有值的对象来调用 equals </p>
<p><font color="green">正例：</font> “test”.equals(object);</p>
<p><font color="red">反例：</font> object.equals(“test”);</p>
<p><font color="orange">说明：</font> 推荐使用工具类 java.util.Objects#equals(Object a, Object b)</p>
<p>7、<font color="red">【强制】</font>  所有整型包装类对象之间的值比较，全部使用 equals 方法比较</p>
<p><font color="orange">说明：</font> 对于 Integer var = ? 在 -128 到 127 之间的赋值，Integer 对象在 IntegerCache.cache 产生，会复用</p>
<p>已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆中产生，并不会复用已有对象，所以就算值相等，直接 == 判断并不是同一个对象；</p>
<p>8、<font color="red">【强制】</font> 任何货币金额，均以最小货币单位且整型类型进行存储</p>
<p>9、<font color="red">【强制】</font> 浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断</p>
<p><font color="orange">说明：</font> 浮点数采用”尾数+阶码“的编码方式，类似于科学记数法的”有效数字+指数“的表示方式，二进制无法精确表示大部分的十进制小数；</p>
<p><font color="green">正例：</font></p>
<p>1、指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0F</span> - <span class="number">0.9F</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>;</span><br><span class="line"><span class="keyword">float</span> diff = <span class="number">1e-6F</span>;</span><br><span class="line"><span class="keyword">if</span>(Math.abs(a - b) &lt; diff)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2、使用 BigDecimal 来定义值，再进行浮点数的运算操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">BigDecimal x = a.subtract(b);</span><br><span class="line">BigDecimal y = b.subtract(c);</span><br><span class="line"><span class="keyword">if</span>(x.compareTo(y) == <span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>


<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型不能用 == 来比较</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.0F</span> - <span class="number">0.9F</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>;</span><br><span class="line">System.out.println(a+<span class="string">&quot;|&quot;</span>+b+<span class="string">&quot;|&quot;</span>+(a-b));</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 0.100000024|0.099999964|5.9604645E-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装数据类型不能用 equals 来判断</span></span><br><span class="line">Float x = Float.valueOf(a);</span><br><span class="line">Float y = Float.valueOf(b);</span><br><span class="line"><span class="comment">// x.equals(y) 输出为false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yannickCao/blogimg/raw/master/img/20210609101731.png"></p>
<blockquote>
<p>整数部分 + 小数部分，因此最终得到的结果二进制结果为<code>110.01011100...</code></p>
<p>按照 <strong>尾数 + 阶码</strong> 的计算机技术方式，可以表示为： *<em>1.1001011100…</em>2<sup>2</sup>**</p>
<p><code>System.out.println( 1f == 0.999999999999f );</code>换算一下你就会发现，其实在<code>float</code>类型下，不管是<code>1f</code>还是<code>0.999999999999f</code>，它们的二进制换算结果都是：</p>
<blockquote>
<p>0011111 10000000 00000000 00000000</p>
</blockquote>
<p>所以结果相等</p>
</blockquote>
<p>10、<font color="red">【强制】</font> BigDecimal 的等值比较应该使用 compareTo() 方法，而不是 equals() 方法；</p>
<p><font color="orange">说明：</font> equals 方法会比较值和精度(1.0 和 1.00 返回结果会是 false)，而 compareTo 则会忽略精度</p>
<p>11、<font color="red">【强制】</font> 定义数据对象 DO 时，属性类型要与数据库字段类型相匹配（bigint必须是类属性的Long，如果实际设置为 Integer，表示范围可能会溢出成为负数）</p>
<p>12、<font color="red">【强制】</font> 禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象</p>
<p><font color="orange">说明：</font> BigDecimal(double) 存在精度丢失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际的存储值为:0.10000000149</span></span><br><span class="line">BigDecimal g = <span class="keyword">new</span> BigDecimal(<span class="number">0.1F</span>);</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font> 优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double  的 toString，而 Double 的 toString 按照 double 的实际能表达的精度对尾数进行了截断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal r1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">BigDecimal r2 = BigDecimal.valueOf(<span class="number">0.1D</span>);</span><br></pre></td></tr></table></figure>
<p>13、关于基本数据类型与包装数据类型的使用标准</p>
<p>1）<font color="red">【强制】</font> 所有的 POJO 类属性必须使用包装数据类型</p>
<p>2）<font color="red">【强制】</font> RPC 方法的返回值和参数必须使用包装数据类型</p>
<p>3）<font color="orange">【推荐】</font> 所有的局部变量使用基本数据类型</p>
<p><font color="green">正例：</font> 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 的风险</p>
<p><font color="red">反例：</font> 如果上涨下跌用 ±x% 表示，x为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示 0%， 这个是不合理的，应该显示 -。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出；</p>
<p>14、<font color="red">【强制】</font> 定义 DO 、DTO、VO 等 POJO 类时，不要设定任何属性的默认值</p>
<p><font color="red">反例：</font> POJO 的 createTime 默认值设置为了 new Date()，在数据提取时并没有设置具体值，在更新其他字段的时候又附带更新了此字段，导致创建时间不断更新为最新事件</p>
<p>15、<font color="red">【强制】</font> 序列化类新增属性时，不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p>
<p><font color="orange">说明：</font> 注意 serialVersionUID 不一致会抛出序列化运行时异常</p>
<p>16、<font color="red">【强制】</font> 构造方法里面禁止加入任何业务逻辑，如果有初始化的逻辑，请放在 init 方法中</p>
<p>17、<font color="red">【强制】</font> POJO 类必须写 toString 方法，使用 IDE 中的工具：source -&gt; genearte toString 时，如果继承另一个 POJO 类，注意在前面加入 super.toString</p>
<p><font color="orange">说明：</font> 在方法执行抛出异常时，可以直接调用 POJO 的 toString 打印属性值</p>
<p>18、<font color="red">【强制】</font> 禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx() 和 getXxx() 方法；</p>
<p>19、<font color="orange">【推荐】</font> 使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOufOfBoundsException 的风险</p>
<p>20、<font color="orange">【推荐】</font> 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起</p>
<p>21、<font color="orange">【推荐】</font> 类内方法定义的顺序依次是：共有方法或者保护方法 》 私有方法 》getter、setter方法</p>
<p>22、<font color="orange">【推荐】</font> setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名 在getter/ setter 方法中，不要增加业务逻辑，增强排查问题的难度</p>
<p>23、<font color="orange">【推荐】</font> 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展</p>
<p><font color="red">反例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  str = str + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 反例中，反编译的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费</p>
<p>24、<font color="orange">【推荐】</font> final 可以声明类，成员变量、方法以及本地变量，下列情况使用 final 关键字：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">不允许被继承的类，如：String 类</span><br><span class="line">不允许修改引用的域对象，如：POJO 类的域变量</span><br><span class="line">不允许被覆写的方法，如：POJO 的 setter 方法</span><br><span class="line">不允许运行过程中重新赋值的局部变量</span><br><span class="line">避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构</span><br></pre></td></tr></table></figure>
<p>25、<font color="orange">【推荐】</font> 慎用 Object 的 clone 方法来拷贝对象</p>
<p><font color="orange">说明：</font> 对象 clone 方法默认的是浅拷贝，若想实现深拷贝，需要覆写 clone 方法来实现域对象的深度遍历式拷贝</p>
<p>26、<font color="orange">【推荐】</font> 类成员与方法访问控制从严：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private</span><br><span class="line">工具类不允许有 public 或 default 构造方法</span><br><span class="line">类非 static 成员变量并且与子类共享，必须是 protected</span><br><span class="line">类非 static 成员变量并且仅在本类使用，必须是private</span><br><span class="line">类 static 成员变量如果仅在本类使用，必须是 private</span><br><span class="line">若是 static 成员变量，考虑是否为 final</span><br><span class="line">类成员方法只供给内部调用，必须是 private</span><br><span class="line">类成员方法只对继承类公开，那么限制为 protected</span><br></pre></td></tr></table></figure>


<p><font color="orange">说明：</font> 严格控制访问范围，利于模块解耦</p>
<h1 id="五、日期时间"><a href="#五、日期时间" class="headerlink" title="五、日期时间"></a>五、日期时间</h1><p>1、<font color="red">【强制】</font> 日期格式化时，传入 pattern 中表示年份统一使用小写的 y</p>
<p><font color="orange">说明：</font> 日期格式化时，yyyy 表示当天在所在年，而大写的 YYYY 表示当天所在的周属于的年份，一周从这周日开始，周六结束，只要本周跨年， YYYY 返回的是下一年</p>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>2、<font color="red">【强制】</font> 在日期格式中 大写 M 表示月份，小写 m 表示分钟，大写 H 表示24小时制，小写 h 表示12 小时制</p>
<p>3、<font color="red">【强制】</font> 获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()</p>
<p><font color="orange">说明：</font> 如果想要获得更加精确的纳秒级时间值，使用 System.nanoTime 的方式，在 JDK8 中，针对统计时间的场景，推荐使用 Instant类</p>
<p>4、<font color="red">【强制】</font> 不允许在程序任何地方中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.Date</span><br><span class="line">java.sql.Time</span><br><span class="line">java.sql.Timestamp</span><br></pre></td></tr></table></figure>
<p><font color="orange">说明：</font> 第一个不记录时间，getHours() 会抛出异常</p>
<p>第二个不记录日期，getYear() 会抛出异常</p>
<p>第三个在构造方法 super((time/1000)*1000)，在属性 Timestamp 属性的 fastTime 和 nanos 分别存储秒和纳秒信息</p>
<p><font color="red">反例：</font> java.util.Date.after(Date) 进行时间比较时，当入参是 java.sql.Timestamp 时，会触发 JDK BUG（JDK9 一修复），可能导致比较时的意外结果</p>
<p>5、<font color="red">【强制】</font> 不要再程序中写死一年为365天，避免在公历闰年时出现日期转换错误或者逻辑错误</p>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取今年的天数</span></span><br><span class="line"><span class="keyword">int</span> daysOfThisYear = LocalDate.now().lengthOfYear();</span><br><span class="line"><span class="comment">// 获取指定某年的天数</span></span><br><span class="line"><span class="keyword">int</span> daysOfThisYear = LocalDate.of(<span class="number">2020</span>,<span class="number">1</span>,<span class="number">1</span>).lengthOfYear();</span><br></pre></td></tr></table></figure>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种情况，在闰年365天，出现数组越界异常</span></span><br><span class="line"><span class="keyword">int</span> dayArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">365</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况，一年有效期的会员，今年1月26日注册，硬编码365返回的确实1月25日</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calender.set(<span class="number">2020</span>,<span class="number">1</span>,<span class="number">26</span>);</span><br><span class="line">calender.add(Calendar.DATE, <span class="number">365</span>);</span><br></pre></td></tr></table></figure>
<p>6、<font color="orange">【推荐】</font> 避免公历闰年2月的问题，一年后的同一天不是2月29日，而是3月1日</p>
<p>7、<font color="orange">【推荐】</font> 使用枚举值来指代月份，如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值在0-11之间</p>
<p><font color="orange">说明：</font> 参考 JDK 原生注释，Month value is 0-based. e.g., 0 for January.<br><font color="green">正例：</font> Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或 比较。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码规范</tag>
        <tag>阿里Java手册</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习（一）：基础语句</title>
    <url>/2021/02/04/RabbitMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="一、-服务器设置"><a href="#一、-服务器设置" class="headerlink" title="一、 服务器设置"></a>一、 服务器设置</h1><h2 id="1、服务器启动与关闭"><a href="#1、服务器启动与关闭" class="headerlink" title="1、服务器启动与关闭"></a>1、服务器启动与关闭</h2><p>启动服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq -server -detached</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
<p>关闭服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关闭：rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>
<p>若单机有多个实例，则在 rabbitmqctl 后加 -n 指定名称</p>
<p>清除所有数据，要在 stop_app 之后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl reset </span><br></pre></td></tr></table></figure>
<a id="more"></a>



<h2 id="2、插件管理"><a href="#2、插件管理" class="headerlink" title="2、插件管理"></a>2、插件管理</h2><p>开启某个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable 插件名称</span><br></pre></td></tr></table></figure>
<p>关闭某个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins disable 插件名称</span><br></pre></td></tr></table></figure>
<p>重启服务器后生效</p>
<h2 id="3、virtual-hosts管理"><a href="#3、virtual-hosts管理" class="headerlink" title="3、virtual hosts管理"></a>3、virtual hosts管理</h2><p>新建virtual_host:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_vhost XXX</span><br></pre></td></tr></table></figure>
<p>删除 virtual_host：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_vhost XXX</span><br></pre></td></tr></table></figure>
<p>列出所有虚拟机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list vhosts</span><br></pre></td></tr></table></figure>
<p>列出虚拟主机上的所有权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_permissions [-p vhostpath]</span><br></pre></td></tr></table></figure>




<h2 id="4、-服务器状态信息"><a href="#4、-服务器状态信息" class="headerlink" title="4、 服务器状态信息"></a>4、 服务器状态信息</h2><ul>
<li>服务器状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure>
<ul>
<li><p>队列信息 queue</p>
<p>queueinfoitem包含：name，durable，auto_delete，arguments，message_ready，messages_unacknowledged，messages，consumers，memory</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_queues [-p vhostpath] [queueinfoitem]</span><br></pre></td></tr></table></figure>
<p>清除队列里的消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl [-p vhostpath] purge_queue blue </span><br></pre></td></tr></table></figure>


<ul>
<li><p>交换机信息exchange</p>
<p>exchangeinfoitem 包含name， type，durable，auto_delete，internal，arguments</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_exchanges [-p vhostpath] [exchangeinfoitem]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>绑定信息binding</p>
<p>bindinginfoitem 包含source_name，source_kind，destination_name，destination_kind，routing_key，arguments</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_bindings [-p vhostpath] [bindinginfoitem]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>集合信息collection</p>
<p>collcetionsinfoitem 包含 recv_oct，recv_cnt，send_oct，send_cnt，send_pend</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_collections [-p vhostpath] [collcetioninfoitem]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通道信息 channel</p>
<p>chnanleinfoitem 包含 consumer_count， message_unknowledged，messages_uncommited，acks_uncommitted，prefetch_count，client_flow_blocked</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_channels [-p vhostpath] [chnanleinfoitem]</span><br></pre></td></tr></table></figure>


<h2 id="5、其他常用命令"><a href="#5、其他常用命令" class="headerlink" title="5、其他常用命令"></a>5、其他常用命令</h2><p>组成集群指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl join_cluster &lt;clusternode&gt; [--ram]</span><br></pre></td></tr></table></figure>
<p>查看集群状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cluster status</span><br></pre></td></tr></table></figure>
<p>修改集群节点的存储方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl change_cluster_node type disc|ram</span><br></pre></td></tr></table></figure>
<p>忘记节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node [--offline]</span><br></pre></td></tr></table></figure>
<p>修改节点名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl rename_cluster_node oldnode1 newnode1</span><br></pre></td></tr></table></figure>




<h1 id="二、用户管理"><a href="#二、用户管理" class="headerlink" title="二、用户管理"></a>二、用户管理</h1><ol>
<li>新增一个用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user 用户名 密码</span><br></pre></td></tr></table></figure></li>
<li>删除用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user 用户名</span><br></pre></td></tr></table></figure></li>
<li>修改密码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl change_password 用户名 新密码</span><br></pre></td></tr></table></figure></li>
<li>列出所有用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h1 id="三、用户角色"><a href="#三、用户角色" class="headerlink" title="三、用户角色"></a>三、用户角色</h1><h2 id="1、用户角色分类"><a href="#1、用户角色分类" class="headerlink" title="1、用户角色分类"></a>1、用户角色分类</h2><font size=2>

<ol>
<li><p>其他（none）<br> 不能访问 management plugin</p>
</li>
<li><p>普通管理者（management）<br> 用户可以通过 AMQP 做的任何事情外加上：<br> 列出自己可以通过 AMQP 登入的 virtual hosts；<br> 查看自己的 virtual hosts 中的 queues， exchanges 和 bindings；<br> 查看和关闭自己的 channels 和 connections；<br> 查看有关自己的 virtual hosts 的“全局”统计信息，包含其他用户在这些 virtual hosts中的活动</p>
</li>
<li><p>策略制定者（polocymaker）<br> management权限加上<br> 查看、创建和删除自己的 virtual hosts 所属的 policies 和 parameters；</p>
</li>
<li><p>监控者（monitoring）<br> management权限加上<br> 列出所有的 virtual hosts，包括他们不能登陆的 virtual hosts；<br> 查看其它用户的 connections 和 channels；<br> 查看节点级别的数据如 clustering 和 memory 使用情况；<br> 查看真正的关于所有 virtual hosts 的全局统计信息；</p>
</li>
<li><p>超级管理员（administrator）<br> policymaker和monitoring权限加上<br> 创建和删除 virtual hosts；<br> 查看、创建和删除 users；<br> 查看、创建和删除 permissions；<br> 关闭其它用户的 connections；</p>
</li>
</ol>
</font>

<h2 id="2、设置用户角色"><a href="#2、设置用户角色" class="headerlink" title="2、设置用户角色"></a>2、设置用户角色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags 用户名 角色名1 角色名2</span><br></pre></td></tr></table></figure>
<p>角色名可以选择的值是：administrator，monitoring，policymaker，management，或者其它自定义名称</p>
<h1 id="四、用户权限"><a href="#四、用户权限" class="headerlink" title="四、用户权限"></a>四、用户权限</h1><p>用户权限指的是用户对 exchange， queue 的操作权限，包括配置权限，读写权限。</p>
<ul>
<li><p>配置权限：影响到 exchange， queue 的声明和删除；</p>
</li>
<li><p>读写权限：影响到从 queue 里去消息，想 exchange 发送消息以及 queue 和 exchange 的绑定操作。</p>
</li>
</ul>
<p>例子：</p>
<ul>
<li><p>将 queue 绑定到某 exchange 上，需要1、queue 的可写权限，2、exchange 的可读权限；</p>
</li>
<li><p>向 exchange 发送消息需要具有 exchange 的可写权限；</p>
</li>
<li><p>从 queue 里取数据需要具有 queue 的可读权限</p>
</li>
</ul>
<ol>
<li><p>设置用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions [-p vhostpath] User ConfP WriteP ReadP</span><br></pre></td></tr></table></figure>
<p>Vhostpath：虚拟host 路径    ConfP：配置权限    WriteP：写权限    ReadP：读权限</p>
</li>
<li><p>查看（指定hostpath）所有用户的权限信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_permissions [-p VHostPath]</span><br></pre></td></tr></table></figure></li>
<li><p>查看指定用户的权限信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_user_permissions 用户名</span><br></pre></td></tr></table></figure></li>
<li><p>清除用户的权限信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions [-p VHostPath] 用户名</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc</title>
    <url>/2021/05/31/SpringMvc/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMvc静态资源路径的总结</title>
    <url>/2021/05/28/SpringMvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo语法大全</title>
    <url>/2021/01/29/hexo%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>语法大全</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法（一）：常用 md 语法</title>
    <url>/2021/01/29/markdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>个人小站建站之后需要用到md 语法， 马上归纳一波</p>
<a id="more"></a>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>
<!-- more -->



<h1 id="二、超链接"><a href="#二、超链接" class="headerlink" title="二、超链接"></a>二、超链接</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[超链接显示名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line"></span><br><span class="line">[百度](www.baidu.com &quot;百度title&quot;)</span><br></pre></td></tr></table></figure>
<p><a href="www.baidu.com" title="百度title">百度</a></p>
<h1 id="三、插入图片"><a href="#三、插入图片" class="headerlink" title="三、插入图片"></a>三、插入图片</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">![图片alt](图片链接 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">![我的头像描述](https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=3857178909,1439464362&amp;fm=218&amp;app=2&amp;f=JPEG?w=121&amp;h=75&amp;s=D218AE6649A0ECDCC8268B680200307F &quot;我的头像标题&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=3857178909,1439464362&fm=218&app=2&f=JPEG?w=121&h=75&s=D218AE6649A0ECDCC8268B680200307F" alt="我的头像描述" title="我的头像标题"></p>
<h1 id="四、字体"><a href="#四、字体" class="headerlink" title="四、字体"></a>四、字体</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*倾斜*</span><br><span class="line">***加粗倾斜***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p><strong>加粗</strong></p>
<p><em>倾斜</em></p>
<p><strong><em>加粗倾斜</em></strong></p>
<p><del>删除</del></p>
<h1 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用的内容</span><br><span class="line"></span><br><span class="line">&gt;&gt; 多次引用的内容</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 引用csdn</p>
</blockquote>
<blockquote>
<blockquote>
<p>​    引用引用csdn</p>
</blockquote>
</blockquote>
<h1 id="六、分割线"><a href="#六、分割线" class="headerlink" title="六、分割线"></a>六、分割线</h1><p>分割线使用三个或三个以上的”-“ 或者 ”*“ 都可以</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>


<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><p>列表分为无序列表和有序列表</p>
<ol>
<li>无序列表使用”-“，”+“，”*“ 任意一种都可以</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>有序猎豹使用数字加点”1.“ 的形式，注意：”.“ 跟内容之间需要空格</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>任务列表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] 计划任务</span><br><span class="line">- [x] 完成任务</span><br></pre></td></tr></table></figure>
<ul>
<li><input disabled="" type="checkbox"> 计划任务</li>
<li><input checked="" disabled="" type="checkbox"> 完成任务</li>
</ul>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">左对齐：|:--</span><br><span class="line"> 居中：|---</span><br><span class="line">右对齐：|--:</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="九、代码内容"><a href="#九、代码内容" class="headerlink" title="九、代码内容"></a>九、代码内容</h1><p>插入单行代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>
<p>插入代码块</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">​```语言类型</span><br><span class="line">代码内容</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>


<h1 id="十、自动转换"><a href="#十、自动转换" class="headerlink" title="十、自动转换"></a>十、自动转换</h1><p>使用&lt;可识别内容&gt;的语法，通过&lt;&gt;来完成自动转换，这个也是下一节中使用html等高级技巧的基础语法。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;可识别内容&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>如果需要显示“&lt;” 和 “&gt;” ，需要使用  “&amp;lt;” 代替 “&lt;” , 使用 “&amp;gt;” 代替 “&gt;”。 例如要输出&lt;a&gt;，则需要写为 &amp;lt;a&amp;gt;，此处也使用了转义符号 “\”</p>
<h1 id="十一、使用html-标签"><a href="#十一、使用html-标签" class="headerlink" title="十一、使用html 标签"></a>十一、使用html 标签</h1><h2 id="1、更改字体、大小、颜色"><a href="#1、更改字体、大小、颜色" class="headerlink" title="1、更改字体、大小、颜色"></a>1、更改字体、大小、颜色</h2><ol>
<li><p>字体修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font face="黑体">我是黑体字</font></p>
<p><font face="STCAIYUN">我是华文彩云</font></p>
</li>
<li><p>大小修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font size=1>我是尺寸1</font></p>
<p><font size=5>我是尺寸5</font></p>
</li>
<li><p>颜色修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font color=#008000>我是绿色</font></p>
<p><font color=Blue>我是蓝色</font></p>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p>
<h2 id="2、为文字添加背景色"><a href="#2、为文字添加背景色" class="headerlink" title="2、为文字添加背景色"></a>2、为文字添加背景色</h2><p>由于 style 标签和标签的 style 属性不被支持，所以这里只能是借助 table， tr， td 等表格标签的 bgcolor 来实现背景色，这里对于文字背景色的设置，只是将那一整行看做一个表格。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<table><tr><td bgcolor=yellow>背景色yellow</td></tr></table>



<h2 id="3、设置文字居中"><a href="#3、设置文字居中" class="headerlink" title="3、设置文字居中"></a>3、设置文字居中</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;居中&lt;/center&gt;</span><br><span class="line">&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<center>居中</center>

<p align="left">左对齐</p>

<p align="right">右对齐</p>

<h2 id="4、加入上下标"><a href="#4、加入上下标" class="headerlink" title="4、加入上下标"></a>4、加入上下标</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br><span class="line">CO&lt;sub&gt;2&lt;/sub&gt;</span><br><span class="line">爆米&lt;sup&gt;TM&lt;/sup&gt;</span><br></pre></td></tr></table></figure>
<p>H<sub>2</sub>O </p>
<p>CO<sub>2</sub></p>
<p>爆米<sup>TM</sup></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>语法大全</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法（二）：图的使用</title>
    <url>/2021/02/01/markdown%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、流程图"><a href="#一、流程图" class="headerlink" title="一、流程图"></a>一、流程图</h1><a id="more"></a>

<h2 id="1、横向流程图："><a href="#1、横向流程图：" class="headerlink" title="1、横向流程图："></a>1、横向流程图：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>
<h2 id="2、竖向流程图源码格式："><a href="#2、竖向流程图源码格式：" class="headerlink" title="2、竖向流程图源码格式："></a>2、竖向流程图源码格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>
<h2 id="3、标准流程图源码格式："><a href="#3、标准流程图源码格式：" class="headerlink" title="3、标准流程图源码格式："></a>3、标准流程图源码格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<h2 id="4、标准流程图源码格式（横向）："><a href="#4、标准流程图源码格式（横向）：" class="headerlink" title="4、标准流程图源码格式（横向）："></a>4、标准流程图源码格式（横向）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>


<h1 id="二、UML时序图源码样例："><a href="#二、UML时序图源码样例：" class="headerlink" title="二、UML时序图源码样例："></a>二、UML时序图源码样例：</h1><h2 id="1、简单UML"><a href="#1、简单UML" class="headerlink" title="1、简单UML"></a>1、简单UML</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;sequence</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>
<h2 id="2、复杂UML时序图源码复杂样例："><a href="#2、复杂UML时序图源码复杂样例：" class="headerlink" title="2、复杂UML时序图源码复杂样例："></a>2、复杂UML时序图源码复杂样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;sequence</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>
<h2 id="3、UML标准时序图样例："><a href="#3、UML标准时序图样例：" class="headerlink" title="3、UML标准时序图样例："></a>3、UML标准时序图样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>
<h1 id="三、甘特图样例："><a href="#三、甘特图样例：" class="headerlink" title="三、甘特图样例："></a>三、甘特图样例：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>语法大全</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 学习：初步了解redis</title>
    <url>/2021/02/05/redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h1><p>redis 是一种非关系型数据库（NoSQL），key-value 数据库，内存数据库，支持持久化，事务和备份，集群（支持16个库），等高可用功能，并且性能高（可达到每秒 100000+ 次查询），易扩展，丰富的数据类型，所有操作都是单线程，原子性</p>
<a id="more"></a>]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>NoSQl</tag>
      </tags>
  </entry>
  <entry>
    <title>群消息已读回执如何设计？</title>
    <url>/2021/01/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%BE%A4%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>发出一个微信消息，都希望对方尽快看到并尽快回复，但始终不知道对方是否阅读；</p>
<p>发出一个钉钉消息，”强制已读回执“ 功能，无法“假装不在线”；</p>
<p>那群消息的流程，接收方如何确保收到群消息，发送发如何收已读回执，是拉取还是推送</p>
<a id="more"></a>





<h1 id="二、群消息投递流程，以及可达性保证"><a href="#二、群消息投递流程，以及可达性保证" class="headerlink" title="二、群消息投递流程，以及可达性保证"></a>二、群消息投递流程，以及可达性保证</h1><h2 id="1、需求解读"><a href="#1、需求解读" class="headerlink" title="1、需求解读"></a>1、需求解读</h2><ul>
<li><p><strong>核心问题1：群消息，存一份？还是每个成员存一份？</strong></p>
</li>
<li><p><strong>核心问题2：如果群消息只存一份，怎么知道每个成员读了那些消息？</strong></p>
<p>利用群消息的偏序关系，<font color="red">记录每个成员的 last_ack_msgid（last_ack_time）</font>，本消息之前的消息标记为已读，这条消息之后的标记为未读。对于群内的每一个用户，只需要记录一个值即可。</p>
</li>
</ul>
<h2 id="2、数据库设计"><a href="#2、数据库设计" class="headerlink" title="2、数据库设计"></a>2、数据库设计</h2><p>核心数据结构</p>
<ul>
<li><p>群消息表：记录群消息</p>
<p>group_msgs(msgid, gid, sender_uid, time, content);</p>
<p>群消息id，群id，发送方uid，发送时间，发送内容</p>
</li>
<li><p>群成员表：记录群里的成员，以及每个成员收到的最后一条群消息</p>
<p>group_users(gid, uid, last_ack_msgid)</p>
<p>群id，群成员uid，群成员最后收到的一条消息id</p>
</li>
</ul>
<p>业务场景</p>
<ol>
<li>一个群中有a，uid1，uid2，uid3四名用户；</li>
<li>a，uid1，uid2在线，期望实时收到在线消息；</li>
<li>uid3 离线，期望未来拉取到离线消息；</li>
</ol>
<p><img src="https://gitee.com/yannickCao/blogimg/raw/master/img/20210203165605.png"></p>
<p>发送流程如上图：</p>
<ol>
<li>a发出群消息</li>
<li>server收到消息后 ，首先要将群消息落地，二来要查询有哪些群成员，以便实施推送；</li>
<li>对于群成员，查询在线状态；</li>
<li>对于在线的群成员，实施推送；</li>
</ol>
<p>在这个流程中，只要第2步消息落地完成，就能保证群消息不会丢失</p>
<ul>
<li><strong>核心问题3：如何保证接收方一定收到群消息？</strong></li>
</ul>
<p>每个用户收到消息后，要修改各群成员的last_ack_msgid，以告诉系统，这一条消息确认收到了</p>
<p>在线用户，离线用户的 last_ack_msgid 的修改，要区别处理</p>
<p><img src="https://gitee.com/yannickCao/blogimg/raw/master/img/20210203172017.png"></p>
<ul>
<li><p><strong>核心问题4：如果ack丢失，群友会不会拉取重复的群消息</strong></p>
<p>会的，可以根据 msgid 在客户端本地进行去重，即使收到了重复的消息，可以不显示</p>
</li>
</ul>
<h1 id="三、已读回执流程"><a href="#三、已读回执流程" class="headerlink" title="三、已读回执流程"></a>三、<strong>已读回执流程</strong></h1><p>新的业务：对于发送方发送的任何一条群消息，都需要知道有多少人已读，多少人未读，就需要新表来记录这个关系</p>
<p>消息回执表：用来记录消息的已读回执</p>
<p>msg_acks(sender_uid, msgid, recv_uid, gid, if_ack);</p>
<p>发送方uid，消息id，回执方uid，群id，回执标记</p>
<p>增加了已读回执逻辑后，群消息的流程会有细微的改变</p>
<p><img src="https://gitee.com/yannickCao/blogimg/raw/master/img/image-20210203174234042.png" alt="image-20210203174234042"></p>
<p>接收方修改 last_ack_msgid 的流程，会变为</p>
<ol>
<li>发送 ack 请求；</li>
<li>修改 last_ack_msgid ，并且修改已读回执 if_ack 状态；</li>
<li>查询发送方在线状态；</li>
<li>如果发送方在线：向发送方实时推送已读回执；</li>
<li>如果发送方不在线：从关联表里拉取每条消息的已读回执；</li>
</ol>
<p>初步结论</p>
<ul>
<li>如果发送方在线：会实时被推送已读回执；</li>
<li>如果发送方不在线：会在下次在线时拉取已读回执；</li>
</ul>
<h1 id="四、流程优化方案"><a href="#四、流程优化方案" class="headerlink" title="四、流程优化方案"></a>四、流程优化方案</h1><p>群已读回执的“信息风暴扩散系数”，假设每个群有200个用户，其中40个用户在线，群用户每发送一条群消息，会有</p>
<ol>
<li>40个消息，通知给群友；</li>
<li>40个 ack 修改 last_ack_msgid， 发给服务端；</li>
<li>40个已读回执，通知给发送方；</li>
</ol>
<p>可见，其<font color=red>信息风暴扩散系数很大</font></p>
<p>同时，需要存储40条 ack 记录；</p>
<p>群数量，群友数量，群消息数量越来越多之后，存储也会成为问题</p>
<p>优化方案</p>
<ol>
<li><p><strong>群消息的推送，能否改为接收方轮询拉取</strong>：<font color=red>不能</font>，消息接收，需要注重实时性；</p>
</li>
<li><p><strong>对于 last_ack_msgid 的修改，真的需要每个群消息都进行 ack 吗</strong>：<font color=red>不需要</font>，可以批量ack，累计收到 N 条群消息后（10条），再向服务器发送一次 last_ack_msgid 的修改请求，同时修改这个请求之前所有请求的已读回执，这样就能将 40 个发送服务端的 ack 请求，降为 1/10；</p>
<p><strong>累计修改 last_ack_msgid 带来的副作用</strong>：last_ack_msgid 的作用是，记录接收方最近新取得一条群消息，如果不实时更新，可能导致，异常退出时，有一些群消息没来得及更新 last_ack_msgid ，使得下次登录时，拉取到重复的群消息，可以通过在客户端msgid去重，不影响用户体验；</p>
</li>
<li><p><strong>发送方在线时，对于已读回执的发送，真的需要实时推送吗：</strong>不需要，发送方每发一条消息，会收到40个回执，采用轮询拉取（例如1分钟一次，一小时也就是60个请求），可以大大降低请求量（或者直接放到应用层 keepalive 的请求里，做到0额外请求）；</p>
<p><strong>带来的副作用</strong>：<font color=red>已读回执更新不实时</font>，最坏情况下，1分钟才更新回执，当然可以根据性能与产品体验来折中配置轮询时间；</p>
</li>
<li><p><strong>如何降低数据量：</strong>回执数据不实核心数据</p>
<ul>
<li>已读的消息，可以进行物理删除，而不是标记删除；</li>
<li>超过N 长时间的回执，归档或者删除；</li>
</ul>
</li>
</ol>
<h1 id="五、总结："><a href="#五、总结：" class="headerlink" title="五、总结："></a>五、总结：</h1><ul>
<li><p>对于群消息已读回执，一般来说：</p>
<ul>
<li><p>如果发送方在线：实施被<font color=red>推</font>送已读回执；</p>
</li>
<li><p>如果发送方不在线：会在下次在线时<font color=red>拉</font>已读回执；</p>
</li>
</ul>
</li>
<li><p>如果要进行优化，可以</p>
<ul>
<li>接收方累计收到 N 条群消息再 <font color=red>批量ack</font>；</li>
<li>发送方<font color=red>轮询拉取</font>已读回执；</li>
<li><font color=red>物理删除</font>已读回执数据，定时删除或归档非核心历史数据；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式语法学习</title>
    <url>/2021/06/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>最近做项目的时候需要过滤富文本框的内容，正好复习一下之前归纳的正则表达式内容，不定时更新这个专题（笑~</p>
<p>先推荐一个测试正则表达式的网站，挺好用的</p>
<p><a href="https://regexper.com/#">https://regexper.com/#%0A</a></p>
<a id="more"></a>

<hr>
<h1 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h1><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或者一个原义字符，或一个向后引用，或一个八进制转义符</td>
<td>‘’\n’表示换行符，序列’’\\‘ 匹配’\‘</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^abc，匹配以abc 为开头的字符</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
<td>^ab*$，匹配以a开头，0个或者多个b结尾的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母，数字，下划线，汉字</td>
<td></td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
<td></td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td></td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或者结束，<font color=red><strong>单词边界指的是单词与符号之间的边界</strong></font>，单词可以是中文字符，英文字符，数字；符号可以是中文符号，英文符号，空格，制表符，换行</td>
<td>\babc，匹配以abc 开头的字符串。单词边界如anb?1fg1，就是anb 和 fg1</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的所有字符</td>
<td></td>
</tr>
<tr>
<td>\W</td>
<td>反义字符、匹配任意不是字母，数字，下划线，汉字的字符</td>
<td></td>
</tr>
<tr>
<td>\S</td>
<td>反义字符，匹配任意不是空白符的字符</td>
<td></td>
</tr>
<tr>
<td>\D</td>
<td>反义字符，匹配任意非数字的字符</td>
<td></td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
<td></td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了字符x意外的任意字符</td>
<td>\Ba</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字符意外的任意字符</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h1 id="二、重复限定词"><a href="#二、重复限定词" class="headerlink" title="二、重复限定词"></a>二、重复限定词</h1><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复0次或者多次</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>重复1次或者多次</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>重复0次或者1次</td>
<td></td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
<td>^\d{8}$，匹配8位数字</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
<td>^\d{14,18}$，匹配14-18位数字</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>用小括号来做分组，如果匹配字符本来就包含括号，可以用’\‘ 转义</td>
<td>^(ab)，匹配ab开头的字符串</td>
</tr>
</tbody></table>
<hr>
<h1 id="三、其他符号"><a href="#三、其他符号" class="headerlink" title="三、其他符号"></a>三、其他符号</h1><h2 id="1、条件或"><a href="#1、条件或" class="headerlink" title="1、条件或 |"></a>1、条件或 |</h2><p>匹配枚举手机号段，并列筛选</p>
<p>^(130|131|132|155|156|185|186|145|176)\d{8}$</p>
<h2 id="2、区间"><a href="#2、区间" class="headerlink" title="2、区间[]"></a>2、区间[]</h2><blockquote>
<p>正则表达式提供一个元字符中括号[]来表示区间条件</p>
<p>1、限定0到9：[0-9]</p>
<p>2、限定A到Z：[A-Z]</p>
<p>3、限定某些数字[165]</p>
</blockquote>
<p>利用区间，上述判断手机号段的正则表达式可以改成</p>
<p>^(13[0-2]|15[56]|18[5-6]|145|176)\d{8}$</p>
<hr>
<h1 id="四、进阶知识"><a href="#四、进阶知识" class="headerlink" title="四、进阶知识"></a>四、进阶知识</h1><h2 id="1、零宽断言"><a href="#1、零宽断言" class="headerlink" title="1、零宽断言"></a>1、零宽断言</h2><h3 id="（1）正向先行断言"><a href="#（1）正向先行断言" class="headerlink" title="（1）正向先行断言"></a>（1）正向先行断言</h3><ul>
<li>语法：?=pattern</li>
<li>作用：匹配 pattern 表达式的前面内容，不返回本身</li>
</ul>
<p>看一个例子：获取其中阅读数的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;read-count&quot;</span>&gt;</span>阅读数：641<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此处如果要获取阅读数，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String reg = <span class="string">&quot;\\d+(?=&lt;/span&gt;)&quot;</span>;</span><br><span class="line">String test = <span class="string">&quot;&lt;span class=&quot;</span>read-count<span class="string">&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span>;</span><br><span class="line"> Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> Matcher mc = pattern.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;匹配结果：&quot;</span>+mc.group());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：641</span></span><br></pre></td></tr></table></figure>


<h3 id="（2）正向后行断言"><a href="#（2）正向后行断言" class="headerlink" title="（2）正向后行断言"></a>（2）正向后行断言</h3><ul>
<li>语法：(?&lt;=pattern)</li>
<li>作用：匹配pattern表达式的后面内容，不返回本身</li>
</ul>
<p>继续上面阅读数的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String reg = <span class="string">&quot;(?&lt;=&lt;span class=\&quot;read-count\&quot;&gt;阅读数：)\\d+&quot;</span>;</span><br><span class="line">String test = <span class="string">&quot;&lt;span class=&quot;</span>read-count<span class="string">&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span>;</span><br><span class="line"> Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> Matcher mc = pattern.matcher(test);</span><br><span class="line"> <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;匹配结果：&quot;</span>+mc.group());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配结果：641</span></span><br></pre></td></tr></table></figure>


<h3 id="（3）负向先行断言"><a href="#（3）负向先行断言" class="headerlink" title="（3）负向先行断言"></a>（3）负向先行断言</h3><ul>
<li>语法：(?!pattern)</li>
<li>作用：负向值得是”非“的意思，匹配非 pattern 表达式的前面内容，不返回本身</li>
</ul>
<p>例子：我爱祖国，我是祖国的花朵</p>
<p>如果要找到不是”的花朵“前面的祖国</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String test = <span class="string">&quot;我爱祖国，我是祖国的花朵&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;祖国(?!的花朵)&quot;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="（4）负向后行断言"><a href="#（4）负向后行断言" class="headerlink" title="（4）负向后行断言"></a>（4）负向后行断言</h3><ul>
<li>语法：(?&lt;!pattern)</li>
<li>作用：匹配非 pattern 表达式的后面内容，不返回本身</li>
</ul>
<h2 id="2、捕获和非捕获"><a href="#2、捕获和非捕获" class="headerlink" title="2、捕获和非捕获"></a>2、捕获和非捕获</h2><h3 id="（1）-捕获组"><a href="#（1）-捕获组" class="headerlink" title="（1） 捕获组"></a>（1） 捕获组</h3><p>捕获的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p>
<blockquote>
<p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中数字编号或者显示命名的组里，以深度优先进行编号，之后可以通过序号或者名称来使用这些匹配的结果</p>
<p>语法：(exp)</p>
</blockquote>
<p>例子比如匹配手机号 13112345678，可以用分组号段+号码，(1\d{2})(\d{8})</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**分组*/</span></span><br><span class="line">String test = <span class="string">&quot;13112345678&quot;</span>;</span><br><span class="line">String reg=<span class="string">&quot;(1\\d&#123;2&#125;)(\\d&#123;8&#125;)&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;分组的个数有：&quot;</span>+mc.groupCount());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个分组为：&quot;</span>+mc.group(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：13112345678</span><br><span class="line">第1个分组为：131</span><br><span class="line">第2个分组为：12345678</span><br></pre></td></tr></table></figure>
<p>注意：分组0默认是匹配到的全字符串</p>
<p>当然也可以用&lt;&gt;给分组命名</p>
<blockquote>
<p>语法：(?&lt;&gt; exp)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**分组命名*/</span></span><br><span class="line">String test = <span class="string">&quot;13112345678&quot;</span>;</span><br><span class="line">String reg=<span class="string">&quot;(?&lt;haoduan&gt;1\\d&#123;2&#125;)(?&lt;haoma&gt;\\d&#123;8&#125;)&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;分组的个数有：&quot;</span>+mc.groupCount());</span><br><span class="line">  System.out.println(<span class="string">&quot;haoduan分组为：&quot;</span>+mc.group(<span class="string">&quot;haoduan&quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;haoma分组为：&quot;</span>+mc.group(<span class="string">&quot;haoma&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">haoduan分组为：131</span><br><span class="line">haoma分组为：12345678</span><br></pre></td></tr></table></figure>


<h3 id="（2）非捕获组"><a href="#（2）非捕获组" class="headerlink" title="（2）非捕获组"></a>（2）非捕获组</h3><blockquote>
<p>解释：与捕获组刚好相反，用来标识那些不需要捕获的分组，匹配的时候会按照多个组来匹配，但是非捕获组不会出现在结果组里，可以根据需要去保存分组</p>
<p>语法：(?:exp)</p>
</blockquote>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**分组 非捕获组*/</span></span><br><span class="line">String test = <span class="string">&quot;13112345678&quot;</span>;</span><br><span class="line">String reg=<span class="string">&quot;(?:1\\d&#123;2&#125;)(\\d&#123;8&#125;)&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;分组的个数有：&quot;</span>+mc.groupCount());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个分组为：&quot;</span>+mc.group(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：13112345678</span><br><span class="line">第1个分组为：12345678</span><br></pre></td></tr></table></figure>
<p>匹配还是会按照多个分组匹配手机号，但是最后组里只有捕获组，非捕获组不获取</p>
<h2 id="3、-反向引用"><a href="#3、-反向引用" class="headerlink" title="3、 反向引用"></a>3、 反向引用</h2><p>上面的例子说明了捕获组，捕获组可以把结果保存在内存中，那如果我们要在正则表达式中引用到前面的结果时，可以使用到反向引用，即在正则表达式内部进行引用</p>
<p>根据捕获组的命名规则，反向引用可以分为</p>
<blockquote>
<p>1、数字编号组：\k&lt;number&gt; 或者 \number</p>
<p>2、命名编号组：\k&lt;“name”&gt; 或者 &quot;name”</p>
</blockquote>
<p>此处也举一个例子说明，比如现在有一个需求，要在字符串”aabbbbgbddesddfiidddddddd”中匹配重复的字母</p>
<p>先用一般的思维给出一个思路</p>
<blockquote>
<p>1、匹配一个字母</p>
<p>2、匹配下一个字母，检查是否和上一个字母一样</p>
<p>3、如果一样，则匹配成功，否则匹配下一个字符、</p>
</blockquote>
<p>顺着思路我们先来匹配一个字母：\w，但是匹配下一个字母的时候，需要用到上一个字母来进行匹配，那如何记住上一个字母呢？此时就需要用到捕获组；</p>
<p>然后需要把他做成一个分组(\w)，然后就有了一个捕获组(\w)；</p>
<p>然后根据捕获组的反向引用方式，用\1表示第一个捕获组（或者\k&lt;1&gt;），然后用这个捕获组作为条件，用代码测试下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**反向引用*/</span></span><br><span class="line">String test = <span class="string">&quot;aabbbbgbddesddfiiddddddd&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;(\\w)\\1&quot;</span>);</span><br><span class="line">Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">dd</span><br></pre></td></tr></table></figure>
<p>从例子可以看到最后匹配的样子是 (\w)\1</p>
<p>或者一次匹配所有重复的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**反向引用*/</span></span><br><span class="line">String test = <span class="string">&quot;aabbbbgbddesddfiiddddddd&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;(\\w)\\1+&quot;</span>);</span><br><span class="line">Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">bbbb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br><span class="line">ddddddd</span><br></pre></td></tr></table></figure>




<h2 id="4、贪婪和非贪婪"><a href="#4、贪婪和非贪婪" class="headerlink" title="4、贪婪和非贪婪"></a>4、贪婪和非贪婪</h2><h3 id="（1）贪婪"><a href="#（1）贪婪" class="headerlink" title="（1）贪婪"></a>（1）贪婪</h3><p>在正则中默认使用贪婪匹配</p>
<blockquote>
<p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式都能得到匹配的前提下）匹配尽量多的字符。</p>
<p>流程：一次性读入整个字符进行匹配，每当不匹配就舍弃最右边的一个字符，依次匹配和舍弃（回溯法），知道匹配成功或者整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不能少。</p>
</blockquote>
<p>例子，比如在一个字符串中匹配尽量多的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**贪婪*/</span></span><br><span class="line">String reg=<span class="string">&quot;(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)&quot;</span>;</span><br><span class="line">String test=<span class="string">&quot;a61762828 176 2996 8732g11&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;文本：&quot;</span>+test);</span><br><span class="line">System.out.println(<span class="string">&quot;贪婪模式：&quot;</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）匹配结果：&quot;</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）匹配结果：&quot;</span>+m1.group(<span class="number">1</span>));</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）匹配结果：&quot;</span>+m1.group(<span class="number">2</span>));</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">文本：a61762828 176 2996 87321g1</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)</span><br><span class="line">0）全字符匹配结果：617628</span><br><span class="line">0）分组1匹配结果：61</span><br><span class="line">0）分组2匹配结果：7628</span><br><span class="line">1）全字符匹配结果：2996</span><br><span class="line">1）分组1匹配结果：2</span><br><span class="line">1）分组2匹配结果：996</span><br><span class="line">2）全字符匹配结果：87321</span><br><span class="line">2）分组1匹配结果：87</span><br><span class="line">2）分组2匹配结果：321</span><br></pre></td></tr></table></figure>
<p>比如617628 这个结果，本来6176 就已经符合的匹配结果了6（1），176（3），因为贪婪最后会变成61（2），7628（4）</p>
<h3 id="（2）懒惰（非贪婪）"><a href="#（2）懒惰（非贪婪）" class="headerlink" title="（2）懒惰（非贪婪）"></a>（2）懒惰（非贪婪）</h3><blockquote>
<p>懒惰匹配：匹配正则表达式中尽量少包含的重复限定词（在整个表达式都能得到匹配的前提下）</p>
<p>流程：从字符串左边开始往右匹配，每次视图读入字符匹配，匹配成功则返回，否则依次读入下一个字符匹配，直至成功或者字符匹配完</p>
</blockquote>
<p>语法：懒惰量词是在贪婪量词后面加入”?”</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽量少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽量少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽量少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽量少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次或更多次，但尽量少重复</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**懒惰*/</span></span><br><span class="line">String reg=<span class="string">&quot;(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;?)&quot;</span>;</span><br><span class="line">String test=<span class="string">&quot;a61762828 176 2996 87321g1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;文本：&quot;</span>+test);</span><br><span class="line">System.out.println(<span class="string">&quot;懒惰模式：&quot;</span>+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）全字符匹配结果：&quot;</span>+m1.group(<span class="number">0</span>));</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）分组1匹配结果：&quot;</span>+m1.group(<span class="number">1</span>));</span><br><span class="line">  System.out.println(i+<span class="string">&quot;）分组2匹配结果：&quot;</span>+m1.group(<span class="number">2</span>));</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">文本：a61762828 176 2996 87321g1</span><br><span class="line">懒惰模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;?)</span><br><span class="line">0）全字符匹配结果：6176</span><br><span class="line">0）分组1匹配结果：6</span><br><span class="line">0）分组2匹配结果：176</span><br><span class="line">1）全字符匹配结果：2828</span><br><span class="line">1）分组1匹配结果：2</span><br><span class="line">1）分组2匹配结果：828</span><br><span class="line">2）全字符匹配结果：2996</span><br><span class="line">2）分组1匹配结果：2</span><br><span class="line">2）分组2匹配结果：996</span><br><span class="line">3）全字符匹配结果：8732</span><br><span class="line">3）分组1匹配结果：8</span><br><span class="line">3）分组2匹配结果：732</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习（二）：消息模型</title>
    <url>/2021/07/09/RabbitMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本文用springboot 整合 rabbitmq 来说明 RabbitMQ 的多种消息模型，因为 RPC 属于的是接口，并不是 MQ 独有，此处不介绍</p>
<a id="more"></a>

<h1 id="一、模型介绍"><a href="#一、模型介绍" class="headerlink" title="一、模型介绍"></a>一、模型介绍</h1><p><img src="https://gitee.com/yannickCao/blogimg/raw/master/img/20210709094119.png"></p>
<p>1、基本消息模型：生产者-&gt;队列-&gt;单个消费者</p>
<p>2、work 消息模型：生产者-&gt;队列-&gt;多个消费者</p>
<p>3、订阅者模型-Fanout：广播，将消息交给所有绑定到交换机的队列，每个消费者都可以收到同一条消息</p>
<p>4、订阅者模式-Direct：路由，将消息交给跟指定 routeKey 完全一致的队列</p>
<p>5、订阅者模式-Topic：通配符，把消息交给符合 routing pattern（主题模式）的队列</p>
<p>pom.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">  <span class="comment"># rabbitmq</span></span><br><span class="line">    <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">max-threads:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">min-spare-threads:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/rabbitmq</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># rabbitmq</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">100MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment">#超时时间</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment">#开启消息确认模式</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#开启消息送达提示</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#开启不可达消息不会被broker给删除</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment">#acknowledge-mode: manual #设置确认模式手工确认</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">3</span> <span class="comment">#消费者最小数量</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span> <span class="comment"># 消费者最大数量</span></span><br></pre></td></tr></table></figure>


<h1 id="二、模型详解"><a href="#二、模型详解" class="headerlink" title="二、模型详解"></a>二、模型详解</h1><h2 id="1、简单队列"><a href="#1、简单队列" class="headerlink" title="1、简单队列"></a>1、简单队列</h2><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接输入队列名称</span></span><br><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;spring.simple.queue&quot;</span>, msg );</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过注解自动创建 spring.simple.queue 队列， queuesToDeclare注解 如果不存在就会创建</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;spring.simple.queue&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;简单队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2、work模型"><a href="#2、work模型" class="headerlink" title="2、work模型"></a>2、work模型</h2><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;spring.work.queue&quot;</span>, msg);</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkListener</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 多个消费者绑定在同一个队列中</span></span><br><span class="line">    <span class="comment">// 通过注解自动创建 spring.work.queue 队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;spring.work.queue&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work模型一 接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过注解自动创建 spring.work.queue 队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;spring.work.queue&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work模型二 接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、订阅者模式-fanout（广播）"><a href="#3、订阅者模式-fanout（广播）" class="headerlink" title="3、订阅者模式-fanout（广播）"></a>3、订阅者模式-fanout（广播）</h2><p>也可以称为广播模式，流程如下</p>
<ul>
<li>多个消费者，每个消费者都有自己的队列</li>
<li>每个队列都绑定到 Exchange（交换机）</li>
<li>生产者无法决定发送到那些队列，由 Exchange 把消息发送到绑定过的所有队列</li>
<li>队列的消费者都能拿到消息，实现一条消息被多个消费者消费</li>
</ul>
<p>应用场景</p>
<ul>
<li>同时更新多个地方的数据信息，比如多库数据库，或者 redis 缓存等实现多出修改</li>
</ul>
<p>SpringBoot  bean配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* fanout模式交换机</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindingFanout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//durable 是否持久化</span></span><br><span class="line">  <span class="comment">//autoDelete 消息是否自动删除，当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">  FanoutExchange fanoutExchange = <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  Queue personQueue = <span class="keyword">new</span> Queue(PERSON_FANOUT_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(personQueue).to(fanoutExchange);</span><br><span class="line">  Queue moneyQueue = <span class="keyword">new</span> Queue(MONEY_FANOUT_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(moneyQueue).to(fanoutExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中初始化 Exchange 时的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// durable 表示是否持久化，指 mq 重启或者断线后是否存在</span></span><br><span class="line"><span class="comment">// autoDelete 在没有生产者发送消息时是否自动删除</span></span><br><span class="line"><span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE, durable, autoDelete)</span><br></pre></td></tr></table></figure>
<p>其中 Queue 的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// durable 表示是否持久化，指 mq 重启或者断线后是否存在</span></span><br><span class="line"><span class="comment">// exclusive 表示排他性，声明后只对首次声明它的连接可见，并且在断开时自动删除，</span></span><br><span class="line"><span class="comment">// 					其中只针对连接可见，只要是当前 connection 下的信道都可以访问</span></span><br><span class="line"><span class="comment">//					一旦该队列被声明，其他连接无法声明相同名称的排他队列</span></span><br><span class="line"><span class="comment">//					队列即使显式声明为 durable，连接断开时（并不是信道断开）也会被删除</span></span><br><span class="line"><span class="comment">// autoDelete 在没有生产者发送消息时是否自动删除</span></span><br><span class="line"><span class="keyword">new</span> Queue(MONEY_FANOUT_QUEUE, durable, exclusive, autoDelete);</span><br></pre></td></tr></table></figure>
<p>消息也可以持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 增加properties，这个properties 就是消费端 callback函数中的properties</span><br><span class="line"># delivery_mode = 2  持久化消息</span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                      routing_key=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      body=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                        delivery_mode=2,  # make message persistent</span><br><span class="line">                      ))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只需要写交换机的名称，第二个值留空，会分发到所有绑定的列表中</span></span><br><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;spring.fanout.exchange&quot;</span>, <span class="string">&quot;&quot;</span>, msg);</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(PERSON_FANOUT_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;person队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(MONEY_FANOUT_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;money队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4、订阅者模式-direct（路由）"><a href="#4、订阅者模式-direct（路由）" class="headerlink" title="4、订阅者模式-direct（路由）"></a>4、订阅者模式-direct（路由）</h2><p>在 fanout 模式下，一条消息，会被所有订阅的队列消费，但是在特定情况下，我们希望不同的消息被不同的队列消费，这时会用到 Direct 类型的 Exchange，通过 RoutingKey 来划分到不同的队列中</p>
<p>流程如下</p>
<ul>
<li>队列和交换机的绑定，不能再任意绑定，需要指定一个 RoutingKey（路由key）</li>
<li>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</li>
<li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 RoutingKey 进行判断，只有队列的 RoutingKey 与消息的 RoutingKey 完全一致，才会收到消息</li>
</ul>
<p>SpringBoot 配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* direct 模式交换机</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindingDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//durable 是否持久化</span></span><br><span class="line">  <span class="comment">//autoDelete 消息是否自动删除，当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">  DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(DIRECT_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  Queue personQueue = <span class="keyword">new</span> Queue(PERSON_DIRECT_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(personQueue).to(DirectExchange).with(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">  Queue moneyQueue = <span class="keyword">new</span> Queue(MONEY_DIRECT_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(moneyQueue).to(directExchange).with(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 PERSON_QUEUE_KEY 发送到 PERSON_DIRECT_QUEUE</span></span><br><span class="line">amqpTemplate.convertAndSend(DIRECT_EXCHANGE, <span class="string">&quot;person&quot;</span>, msg);</span><br><span class="line"><span class="comment">// 通过 MONEY_QUEUE_KEY 发送到 MONEY_DIRECT_QUEUE</span></span><br><span class="line">amqpTemplate.convertAndSend(DIRECT_EXCHANGE, <span class="string">&quot;money&quot;</span>, msg);</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(PERSON_DIRECT_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;person队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(MONEY_DIRECT_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;money队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5、订阅者模式-Topic（主题）"><a href="#5、订阅者模式-Topic（主题）" class="headerlink" title="5、订阅者模式-Topic（主题）"></a>5、订阅者模式-Topic（主题）</h2><p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 吧消息路由到不同的队列，只不过 Topic 类型 Exchange 可以让队列在绑定 RouteKey 的时候用通配符</p>
<p>Routekey 一般都是有一个或多个单词组成，多个单词之间以”.“分割，例如 user.insert</p>
<table>
<thead>
<tr>
<th>通配符规则</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>#：匹配一个或多个词</td>
<td>person.#：能够匹配 person.insert.save 或者 person.insert</td>
</tr>
<tr>
<td>*：匹配一个词</td>
<td>person.*：只够匹配 person.insert</td>
</tr>
</tbody></table>
<p>SpringBoot bean配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* topic模式交换机</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindingTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//durable 是否持久化</span></span><br><span class="line">  <span class="comment">//autoDelete 消息是否自动删除，当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">  TopicExchange topicExchange = <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  Queue personQueue = <span class="keyword">new</span> Queue(PERSON_TOPIC_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(personQueue).to(topicExchange).with(<span class="string">&quot;person.*&quot;</span>);</span><br><span class="line">  Queue moneyQueue = <span class="keyword">new</span> Queue(MONEY_TOPIC_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  BindingBuilder.bind(moneyQueue).to(topicExchange).with(<span class="string">&quot;money.*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(TOPIC_EXCHANGE, <span class="string">&quot;person.insert&quot;</span>, <span class="string">&quot;增加人员&quot;</span>);</span><br><span class="line">amqpTemplate.convertAndSend(TOPIC_EXCHANGE, <span class="string">&quot;person.delete&quot;</span>, <span class="string">&quot;删除人员&quot;</span>);</span><br><span class="line"></span><br><span class="line">amqpTemplate.convertAndSend(TOPIC_EXCHANGE, <span class="string">&quot;money.insert&quot;</span>, <span class="string">&quot;加钱&quot;</span>);</span><br><span class="line">amqpTemplate.convertAndSend(TOPIC_EXCHANGE, <span class="string">&quot;money.delete&quot;</span>, <span class="string">&quot;减钱&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收到 &quot;person.insert&quot; 和 &quot;person.delete&quot; 消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(PERSON_TOPIC_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;person队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到 &quot;money.insert&quot; 和 &quot;money.delete&quot; 消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(MONEY_TOPIC_QUEUE))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;money队列 接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发手册学习：编程规约（八、九、十、十一）</title>
    <url>/2021/06/21/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="八、控制语句"><a href="#八、控制语句" class="headerlink" title="八、控制语句"></a>八、控制语句</h1><p>1、<font color="red">【强制】</font>每个case要么通过continue/break/return等来终止，要么 注释说明程序将继续执行到哪一个 case 为止;在一个 switch 块内，都必须包含一个 default 20/59</p>
<p>Java 开发手册 语句并且放在最后，即使它什么代码也没有。</p>
<p><font color="orange">说明：</font> 注意 break 是退出 switch 语句块，而 return 是退出方法体。</p>
<p>2、<font color="red">【强制】</font>当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断，直接判断会报错：NPE</p>
<p>3、<font color="red">【强制】</font>在 if / else / for / while / do 语句中必须使用大括号</p>
<p>4、<font color="red">【强制】</font>三目运算符 condition ? 表达式1 : 表达式2 中，注意表达式1 和表达式2在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常</p>
<p><font color="orange">说明：</font> 以下两种场景会触发类型对齐的拆箱操作：</p>
<ul>
<li><p>1、表达式1 或者 表达式2 的值只要有一个是原始类型</p>
</li>
<li><p>2、 表达式1 或者 表达式2 的值类型不一致，会强制拆箱升级成表示范围更大的那个类型</p>
</li>
</ul>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">Integer c = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">Integer result = (flag ? a*b : c);</span><br></pre></td></tr></table></figure>
<p>5、<font color="red">【强制】</font> 在高并发场景中，避免使用”等于“判断作为终端或者退出的条件</p>
<p><font color="orange">说明：</font> 如果并发控制没有处理好，容易产生等值判断被”击穿“的情况，使用大于或者小于的区间判断条件来代替</p>
<p><font color="red">反例：</font> 判断生育奖品等于0时退出循环判断，但因为高并发处理错误导致奖数量瞬间变成负数，导致活动无法终止，应改为 小于等于0；</p>
<p>6、<font color="orange">【推荐】</font>当某个方法的代码总行数不超过 10 行时，return / throw 等中断逻辑的右大括号后均加一个空行</p>
<p>7、<font color="orange">【推荐】</font>表达异常的分支时，少用 if-else ，改写为多个卫语句组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else 分支</span></span><br></pre></td></tr></table></figure>
<p>如果非使用，避免超过3层，导致后续代码维护困难</p>
<p>8、<font color="orange">【推荐】</font>除常用方法 （getXxx / setXxx）外，不要再条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名</p>
<p><font color="red">反例：</font> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((file.open(fileName, &quot;w&quot;) !&#x3D; null) &amp;&amp; (...) || (...)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="green">正例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值给变量再判断</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">&quot;w&quot;</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...); </span><br><span class="line"><span class="keyword">if</span> (existed) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、<font color="orange">【推荐】</font>不要再其他表达式（尤其是条件表达式）中，插入赋值语句</p>
<p><font color="red">反例：</font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">getLock</span><span class="params">(Integer count, <span class="keyword">boolean</span> sync)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 算术表达式中出现赋值操作，容易忽略 count 值已经被改变</span></span><br><span class="line">  Integer param = (count = Integer.MAX_VALUE) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>((count = Integer.MAX_VALUE) &gt; <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 条件表达式中出现赋值操作，容易误认为是 sync==flag</span></span><br><span class="line">    <span class="keyword">return</span> (sync = flag) ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10、<font color="orange">【推荐】</font>循环体中的语句要考量性能，定义对象、变量、获取数据库连接，进行不必要的 try-catch操作等尽量移到循环体外</p>
<p>11、<font color="orange">【推荐】</font>避免采用取反逻辑运算符，采用正向逻辑能有利于快速理解</p>
<p>12、<font color="orange">【推荐】</font>公开接口需要进行入参保护，尤其是批量操作的接口，控制批量操作接口的入参数量，防止内存爆</p>
<p>13、<font color="green">【参考】</font>下列情况，需要进行参数检验</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">调用频次低的方法</span><br><span class="line">执行时间开销很大的方法中，参数检验时间几乎忽略不计，但如果因为参数错误导致中间执行回退，或者错误，得不偿失</span><br><span class="line">需要极高稳定性和可用性的方法</span><br><span class="line">对外提供的开放接口，不管是 RPC 、API、HTTP 接口</span><br><span class="line">敏感权限入口</span><br></pre></td></tr></table></figure>
<p>14、<font color="green">【参考】</font>下列情形，不需要进行参数检验</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">极有可能被循环调用的方法，但在方法说明里必须注明外部参数检查</span><br><span class="line">底层调用频率比较高的方法。一般 DAO 层与 Service 层都在同一个应用中，部署在同一个服务器中，所以 DAO 层的参数检验可以省略</span><br><span class="line">被声明成 private 只会被自己代码调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题</span><br></pre></td></tr></table></figure>


<h1 id="九、注释规约"><a href="#九、注释规约" class="headerlink" title="九、注释规约"></a>九、注释规约</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span>: 参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@description</span>: TODO 方法描述</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>: 返回值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span>: 作者</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span>: 时间</span></span><br><span class="line"><span class="comment">	 **/</span></span><br></pre></td></tr></table></figure>
<p>1、<font color="red">【强制】</font>类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用 // xxx 方式。</p>
<p>2、<font color="red">【强制】</font>所有抽象方法（包括接口的方法）必须要用Javadoc注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p>3、<font color="red">【强制】</font>所有的类都必须添加创建者和创建日期</p>
<p>4、<font color="red">【强制】</font>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使 用/* */注释，注意与代码对齐。</p>
<p>5、<font color="red">【强制】</font>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>6、<font color="orange">【推荐】</font>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。</p>
<p>7、<font color="orange">【推荐】</font>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。</p>
<p>8、<font color="orange">【推荐】</font>在类中删除未使用的任何字段、方法、内部类;在方法中删除未使用的任何参数声明 与内部变量。</p>
<p>9、<font color="green">【参考】</font>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</p>
<p>代码被注释掉有两种可能性</p>
<ul>
<li><p>后续会恢复此段代码逻辑。如果没有备注信息， 难以知晓注释动机。</p>
</li>
<li><p>永久不用。建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</p>
</li>
</ul>
<p>10、<font color="green">【参考】</font>对于注释的要求:第一、能够准确反映设计思想和代码逻辑;第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
<p>11、<font color="green">【参考】</font>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一</p>
<p>个极端:过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。</p>
<p>12、<font color="green">【参考】</font>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p>
<ul>
<li><p>待办事宜（TODO）：（标记人，标记时间，[预计处理时间]）表示需要实现</p>
</li>
<li><p>错误，不能工作（FIXME）:(标记人，标记时间，[预计处理时间])，表示需要纠正</p>
</li>
</ul>
<h1 id="十、前后端规约"><a href="#十、前后端规约" class="headerlink" title="十、前后端规约"></a>十、前后端规约</h1><p>1、<font color="red">【强制】</font>前后端交互的 API，需要明确协议，域名，路径，请求方式，请求内容，状态码，响应体</p>
<p><font color="orange">说明：</font> </p>
<p>1）协议：生产环境必须使用 HTTPS。</p>
<p>2）路径：每一个 API 需要对应一个路径，表示 API 具体的请求地址：</p>
<ul>
<li><p>代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义</p>
</li>
<li><p>URL 路径不能使用大写，单词如果需要分隔，统一使用下划线</p>
</li>
<li><p>路径禁止携带表示请求内容类型的后缀，比如 ”*.json“,”.xml”，通过 accept 头表达</p>
</li>
</ul>
<p>3）请求方法:对具体操作的定义，常见的请求方法如下:</p>
<ul>
<li>GET:从服务器取出资源。</li>
<li>POST:在服务器新建一个资源。</li>
<li>PUT:在服务器更新资源。</li>
<li>DELETE:从服务器删除资源。</li>
</ul>
<p>4）请求内容：URL 带的参数必须无敏感信息或符合安全要求；body里待参数时必须设置 Content-Type</p>
<p>5）响应体：响应体 body 设置多种数据类型，由 Content-Type 头来确定</p>
<p>2、<font color="red">【强制】</font>前后端数据列表相关的接口返回，如果为空，则返回数组[] 或空集合{}</p>
<p><font color="orange">说明：</font> 此条约有利于数据层面上的协同更加高效，减少前端很多烦琐的 null 判断</p>
<p>3、服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码，errorCode、errorMessage、用户提示信息四个部分</p>
<p><font color="orange">说明：</font> 四个部分设计对象分别是 </p>
<ul>
<li>HTTP状态码-浏览器</li>
<li>前端开发-errorCode，errorCode:参考<strong>附表</strong> <strong>3</strong>。</li>
<li>错误排查人员-errorMessage，简要描述后端出错原因，便于错误排 查人员快速定位问题，注意不要包含敏感数据信息。</li>
<li>用户提示信息-用户。其中输出给用户的信息力求：简短清晰，提示友好，引导用户进行下一步操作或者解释错误原因。提示信息可以包括错误原因、上 下文环境、推荐操作等。 </li>
</ul>
<p><font color="green">正例：</font>常见的 HTTP 状态码如下</p>
<ul>
<li>200 OK: 表明该请求被成功地完成，所请求的资源发送到客户端。</li>
<li>401 Unauthorized: 请求要求身份验证，常见对于需要登录而用户未登录的情况。</li>
<li>403 Forbidden:服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。</li>
<li>404 Not Found: 服务器无法取得所请求的网页，请求资源不存在。</li>
<li>500 Internal Server Error: 服务器内部错误。</li>
</ul>
<p>4、<font color="red">【强制】</font>在前后端交互的 JSON 格式数据中，所有的 key 必须为小写字母开始的 lowerCamelCase 风格</p>
<p>5、<font color="red">【强制】</font> errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type=”hidden” 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。</p>
<p>6、<font color="red">【强制】</font> 对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型</p>
<p><font color="orange">说明：</font> java 服务端如果直接返回 Long 类型，js会自动转换为 Number 类型。导致精度丢失</p>
<p><font color="red">反例：</font> 订单号或者交易号大于16位，大概率会出现前后端 单据不一致的情况</p>
<p>7、<font color="red">【强制】</font>HTTP请求通过 URL 传递参数时，不能超过 2048 字节</p>
<p>不同浏览器对于 URL 的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048 字节是取所有浏览器的最小值。如果超过最大值导致参数被截断，业务逻辑不完整</p>
<p>8、<font color="red">【强制】</font>HTTP请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出错</p>
<p><font color="orange">说明：</font> nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调大服务器端的限制。</p>
<p>9、<font color="red">【强制】</font>在翻页场景中，用户输入的参数小于1，则前端返回第一页参数给后端，后端发现用户输入的参数大于总页数，直接返回最后一页</p>
<p>10、<font color="red">【强制】</font> 服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否则会因为线上采用 HTTPS 协议而导致浏览器提示 ”不安全“，并且还会带来 URL 维护不一致的问题</p>
<p>11、<font color="orange">【推荐】</font>服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果</p>
<p><font color="orange">说明：</font> 缓存有利于减少交互次数，减少交互的平均延迟。<br><font color="green">正例：</font>http 1.1 中，s-maxage 告诉服务器进行缓存，时间单位为秒，用法如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;s-maxage=&quot;</span> + cacheSeconds);</span><br></pre></td></tr></table></figure>
<p>12、<font color="orange">【推荐】</font> 服务端返回的数据，使用 JSON 格式而不是 XML</p>
<p><font color="orange">说明：</font> 尽管 HTTP 支持使用不同的输出格式，例如纯文本，JSON，CSV，XML，RSS 甚至 HTML。如果我 们使用的面向用户的服务，应该选择 JSON 作为通信中使用的标准数据交换格式，包括请求和响应。此外， application/JSON 是一种通用的 MIME 类型，具有实用、精简、易读的特点。</p>
<p>13、<font color="orange">【推荐】</font>前后端的时间统一格式为”yyyy-MM-dd HH:mm:ss”，统一为 GMT</p>
<p>14、<font color="green">【参考】</font>接口路径中不要加入版本号，版本控制在 HTTP 头信息中体现，有利于向前兼容</p>
<p><font color="orange">说明：</font> 当用户在低版本与高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。</p>
<h1 id="十一、其他规约"><a href="#十一、其他规约" class="headerlink" title="十一、其他规约"></a>十一、其他规约</h1><p>1、<font color="red">【强制】</font> 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度</p>
<p><font color="orange">说明：</font> 不要在方法体内定义:Pattern pattern = Pattern.compile(“规则”);</p>
<p><font color="green">正例：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pattern 表达式要提前定义，不要再需要的地方临时定义；</span></span><br><span class="line"><span class="comment">// Pattern 表达式要定义为 static final 静态变量，以避免执行多次预编译。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern pattern = Pattern.compile(regexRule);</span><br></pre></td></tr></table></figure>
<p>2、<font color="red">【强制】</font> 避免用 Apache Beanutills 进行属性 copy</p>
<p><font color="orange">说明：</font> Apache BeanUtils 性能较差，可以使用其他方案比如：Spring BeanUtils，Cglib BeanCopier，注意均是浅拷贝</p>
<p>3、<font color="red">【强制】</font> veloctiry 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加is前缀），会自动调用 isXxx() 方法</p>
<p>4、<font color="red">【强制】</font>后台输送给页面的变量必须加 $!{var}——中间的感叹号。</p>
<p><font color="orange">说明：</font> 如果 var 等于 null 或者不存在，那么 ${var} 会直接显示在页面上</p>
<p>5、<font color="red">【强制】</font> 注意 Math.random() 这个方法返回的是 double 类型，注意取值范围 0 &lt;= x &lt; 1（能够取到 0 值，所以需要注意除零异常），如果想要获取整数类的随机数，不要把 x 扩大十的若干倍再取整，直接使用 Random 对象的 <strong>nextInt</strong> 或者 <strong>nextLong</strong> 方法</p>
<p>6、<font color="orange">【推荐】</font> 不要在视图模板中加入任何复杂的逻辑，根据 MVC，视图层只负责展示数据</p>
<p>7、<font color="orange">【推荐】</font>任何数据结构的构造或初始化，都应该指定大小，避免数据结构无限增长吃光内存</p>
<p>8、<font color="orange">【推荐】</font>及时清理不再使用的代码段或者配置信息</p>
<p><font color="green">正例：</font>对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///) 来说明注释掉代码的理由。如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 业务方通知活动暂停</span></span><br><span class="line">  <span class="comment">// Business business = new Business(); </span></span><br><span class="line">  <span class="comment">// business.active(); System.out.println(&quot;it&#x27;s finished&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码规范</tag>
        <tag>阿里Java手册</tag>
      </tags>
  </entry>
</search>
